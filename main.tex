\documentclass{book}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\usepackage{makeidx}
\usepackage[unicode]{hyperref}
\usepackage[symbol]{footmisc}
\usepackage{marvosym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{environ}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{longtable}
\usepackage{afterpage}

\title{Робимо програми: шлях хакера}
\author{А. Мустіц}
\date{\today}
\makeindex

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\NewEnviron{exercise}{\par\goodbreak\smallskip\textbf{Вправа:} \BODY \par\smallskip}
\NewEnviron{summary}{\par\goodbreak\smallskip\textbf{Підсумки:}\begin{itemize} \BODY \end{itemize}\par\smallskip}

\NewEnviron{algorithm}{\medskip\goodbreak \BODY \medskip\goodbreak}
%\NewEnviron{algsteps}{\begin{enumerate}[\hspace{2\parindent}1.] \BODY \end{enumerate}}
\NewEnviron{algsteps}{\begin{enumerate}[
  topsep=0pt,itemsep=-1ex,partopsep=1ex,parsep=1ex,
  leftmargin=3\parindent
  ] \BODY \end{enumerate}}
\newcommand{\algcaption}[1]{\textbf{Алгоритм:} #1.\par}
\newcommand{\alginput}[1]{\textbf{Дано:} #1\par}
\newcommand{\algoutput}[1]{\textbf{Треба:} #1\par}
\newcommand{\algstep}{\item}
\newcommand{\algsummary}[1]{\par\textbf{Результат:} #1\par}

\newcommand{\bitstr}[1]{{\tt #1}}
\newcommand{\bitdesc}{послідовність бітів ми будемо писати моноширинним шрифтом, наприклад запис \bitstr{10011} означатиме послідовність п'яти біт \bitstr{1}, \bitstr{0}, \bitstr{0}, \bitstr{1} та \bitstr{1}.}

\newcommand{\hexstr}[1]{{\tt 0x#1}}
\newcommand{\hexdesc}{ми будемо записувати $16$--річні числа моноширинним шрифтом за префіксом {\tt 0x}, наприклад \hexstr{5A}}

\newcommand{\tritzero}{$\square$}
\newcommand{\trithalf}{\Yinyang}
\newcommand{\tritone}{$\blacksquare$}

\newcommand{\setunref}{\href{https://uk.wikipedia.org/wiki/\%D0\%A1\%D0\%B5\%D1\%82\%D1\%83\%D0\%BD\%D1\%8C_(\%D0\%BA\%D0\%BE\%D0\%BC\%D0\%BF\%27\%D1\%8E\%D1\%82\%D0\%B5\%D1\%80)}{https://uk.wikipedia.org/wiki/Сетунь\_(комп'ютер)}}
\newcommand{\quantumref}{\href{https://uk.wikipedia.org/wiki/\%D0\%9A\%D0\%B2\%D0\%B0\%D0\%BD\%D1\%82\%D0\%BE\%D0\%B2\%D0\%B8\%D0\%B9_\%D0\%BA\%D0\%BE\%D0\%BC\%D0\%BF\%27\%D1\%8E\%D1\%82\%D0\%B5\%D1\%80}{https://uk.wikipedia.org/wiki/Квантовий\_комп'ютер}}
\newcommand{\kruskalref}{\href{https://en.wikipedia.org/wiki/Kruskal\%27s_tree_theorem}{https://en.wikipedia.org/wiki/Kruskal\%27s\_tree\_theorem}}

\begin{document}

\maketitle
\chapter{TBD}
\section{TBD}
\subsection{Біти та інформація}

Що таке комп'ютерна програма?
Одне з визначень, яке можна дати, це певні інструкції, як обробляти інформацію.
Що призводить до не менш цікавого запитання: «А що тоді таке інформація?» \index{інформація}
Щоб дати ретельну відповідь на нього, треба написати не одну книжку.
Цей термін часто використовується у повсякденному житті, тому кожен має своє власне інтуїтивне уявлення, яке дуже важко пояснити словами.
Також інформація з'являється в математиці, фізиці, інформатиці, та у багатьох інших дисциплінах.
Як завжди, у кожному такому контексті цей термін обростає своїми особливими рисами та нюансами.

\begin{figure}[t]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{images/qr2.png}
    \caption{~}
    \label{Pic_QR_BW}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{images/qr3.png}
    \caption{~}
    \label{Pic_QR_Color}
  \end{subfigure}
  \caption{На QR коді ми можемо на власні очі побачити біти (а); також показаний гіпотетичний QR код, який складається зі тритів (б).}
  \label{PicQR}
\end{figure}

Але я б хотів виділити один момент, який буде для нас важливим.
Інформація це часто є акцентування однієї з можливих альтернатив.
Наприклад, «Танєєв народився у 1856 році».\footnote{
  Приклад про Танєєва взятий з оповідання Іраклія Андронікова «Перший раз на естраді», яке можна прочитати в інтернеті або подивитися на youtube.
  \par\url{https://www.youtube.com/watch?v=dm8wdFKag94}}
Це означає, що Танєєв не міг народитися у 1858 році, 1859, 1860, 1861, 1862, і т.~д.
Тобто з усіх можливих альтернатив, коли міг народитися Танєєв, ми обираємо одну.
Цього погляду нам вистачить для потреб цієї книги.

Добре, тепер спробуємо поміркувати так, як це роблять програмісти та математики.
Який шмат інформації самий найпростіший?
Інтуїтивно, це вибір однієї з двох альтернатив.
Тому що три це вже забагато, а у разі однієї альтернативи мова не йде про вибір.
«Танєєв народився від батька та матері!»
Це викликає посмішку, бо незрозуміло, які є ще варіанти?
Так, з сучасними технологічними досягненнями у галузі біомедицини, у певному контексті ще можна уявити на чому саме робиться акцент, але не у 1856 році.

Сама дрібна одиниця інформація, а саме вибір однієї з двох альтернатив, називається бітом. \index{біт}
Це може бути орел чи решка, парне або непарне, біле або чорне, хрестик або нулик, \Male\ або \Female, живий або мертвий, уперед чи назад, правда чи брехня.

\begin{exercise}
Придумайте ще приклади інформації, які можна закодувати одним бітом.
\end{exercise}

У сучасній мікроелектроніці, біт це наявність або відсутність електричного сигналу за певний проміжок часу, який називається тактом. \index{такт}
Переважна кількість сучасних процесорів бачать увесь свій світ виключно як послідовність біт.
Коли ми на комп'ютері слухаємо музику, дивимося відео або граємо у 3D ігри, коли робиться автоматичний переклад з однієї мови на іншу, коли автоматично генеруються пейзажі, то інколи дуже важко повірити в те, що віртуальна реальність складається виключно з бітів, але це так.
Однією нашою метою буде як раз пояснення того, як реальний світ може бути змодельований з бітів.

Проте, поширення електронних пристроїв призвело до того, що ми можемо фізично побачити біти навіть у реальному житті.
Гарний приклад цього це QR~коди, де біти видно на власні очі (рис.~\ref{Pic_QR_BW}).
Тут чорні квадратики кодують один стан, а білі---інший.

Оскільки ми будемо вести багато розмов про біти, було б добре їх якось позначати.
Біт може бути у одному з двох станів, тому для цього можна вибрати два будь-яких символи, наприклад $\blacksquare$ та $\square$, як на QR~коді.
Але історично в математиці для цього використовуються числа $0$ та $1$.
Щоб відрізняти звичайні десяткові числа, складені з нулів та одиниць, наприклад, як  $101$ (сто один),  від послідовності біт \bitstr{1}, \bitstr{0} та \bitstr{1}, ми будемо триматися наступних домовленостей:
\bitdesc

За визначенням, один біт може кодувати два різних варіанти. А скільки варіантів кодує два біти? Нескладно порахувати, що відповідь на це запитання буде чотири, ось усі варіанти: \bitstr{00}, \bitstr{01}, \bitstr{10} та \bitstr{11}. Взагалі, якщо ми збільшуємо кількість біт на один, то кількість варіантів зростає у двічі.
Це легко пояснити тим, що для будь якого попередньої комбінації ми можемо додати або біт \bitstr{0}, або біт \bitstr{1}.
Загально, якщо в нас є $n$ біт, то з них можна скласти $2^n$ різних комбінацій.

\begin{exercise}
Побудуйте усі різні комбінації, які можна створити з трьох біт.
\end{exercise}

\begin{exercise}
Скільки усього можливих комбінацій можна скласти з $10$ біт?
\end{exercise}

Я сподіваюся, що до цього моменту ви вже розібралися, що таке біти.
Тому настав час трохи відпочити та пофлудити.
Отже, біт має два стани, які ми позначаємо \bitstr{0} та \bitstr{1}.
Також ми відмітили, що безглуздо розглядати щось, що має лише один стан.
А якщо розглянути систему, яка має три стани, наприклад \tritzero, \tritone\ та \trithalf?
\index{тріт} Назвемо трітом одиницю інформації, де у нас є вибір з трьох альтернатив.

\begin{exercise}
Побудуйте усі різні комбінації, які можна створити з двох тритів.
\end{exercise}

Чи дасть це нам якісь переваги?
З математичної точки зору, усе що можна представити з тритів, можна представити й за допомогою бітів.
Самий простий шлях це зробити просто використовувати два біти для кодування одного тріта: \bitstr{00}~—~\tritzero, \bitstr{11}~—~\tritone\ та \bitstr{01}~—~\trithalf.
Так, звичайно комбінація \bitstr{10} не буде використовуватися.
Так, звичайно бітів буде вдвічі більше ніж тритів.
Але коли це хвилювало математиків?

\begin{exercise}
Скільки біт треба для того, щоб закодувати інформацію, яка міститься у двох трітах?
Скільки комбінацій при цьому не буде використано?
\end{exercise}

Добре, а що з точки зору народного господарства?
Якщо зберігати інформацію у трітах замість бітів, чи не виграємо ми додаткове місце?
Яке не яке, а досягнення.
Але, на практиці усе не так просто.
Безкоштовний газ є тільки у газовій камері.

Подивимося на рис.~\ref{Pic_QR_Color}.
На ньому я намагався нафантазувати, як би мав виглядати QR~код з тритів.
Замість чорної та білої фарб, використано жовту, синю та червоні фарби.
Ніби то виграш є?
Але на практиці розрізняти три фарби складніше.
Тому у звичайному чорно-білому варіанті ми зможемо розрізняти менші квадратики, а це також буде впливати на щільність запису інформацію.

Зробити процесори, які працюють з трітами, не питання.
За радянських часів була побудована ЕОМ Сетунь\footnote{\setunref}, яка працювала з трітами. \index{Сетунь}
Розрізнялися не тільки наявність та відсутність сигналу, але й його напрямок.
Хтось й по сьогоднішній день вважає це революційним досягненням, але я до цього ставлюся скептично.
Проектування процесорів зараз суто технічний процес.
Е багато інструментів, програмних застосунків, які дозволяють моделювати нові процесори.
Цим займається багато спеціалістів по усьому світу, тому усе що можна було перепробувати, вони вже перепробували.
Отже, якщо переважна більшість сучасних комп'ютерів працюють з бітами, то це означає, що не зважаючи на свою привабливість, тріти все ж таки програють бітам.

Але, там де це доречно, то чому б не розглянути?
У WiFi інформація передається символами, кожен з яких може нести величезну кількість варіантів.
Так, оскільки ця інформація у евентуально буде оброблятися звичайним процесором, то з практичної точки зору цю кількість варіантів намагаються зробити ступенями двійки.
Це дає змогу казати, що один символ несе $1024$ біти інформації.
Але у самій електромагнітній хвилі важко побачити окремі біти.

Також скажу декілька слів про квантові обчислення, кубіти, або квантові біти. \index{кубіт}
Так, на сьогодні віртуальний світ складається з бітів. А що у реальному?
Якщо опуститися на рівень квантових взаємодій, ми побачимо, що там працюють свої екзотичні контрінтуїтивні закони.
Окрім двох альтернатив, які виключають одна одну, ми часто бачимо їх суперпозицію.
Наприклад, електрон на $30$\% обертається праворуч, а на $70$\%---ліворуч.
Нам це важко уявити, але математичні формули працюють саме так.
Замість нуля та одиниці, ми отримуємо фізичну величину від нуля до одиниці.
Додайте ще фазу від нуля до $2\pi$, й ви отримаєте кубіт.
А ще суперпозиція станів, зворотні операції, вимірювання...

Вже з'являються перші квантові комп'ютери, які оперують кубітами.
Це може бути новою революцією.
Але на початку все ж таки краще освоїти звичайне програмування, яке працює з бітами.
А вже потім переходити до квантового.

\begin{exercise}
Продивиться статтю у Wikiepedia про квантові комп'ютери\footnote{\quantumref}. Чи це цікаво?
\end{exercise}

\begin{summary}
\item Інформація вимірюється у бітах.  Біт це найменший шмат інформації, який складається з двох станів, які позначаються \bitstr{0} та \bitstr{1}.
\item З $n$ біт можна скласти $2^n$ різних комбінацій.
\end{summary}

\subsection{Числа, скільки біт нам вистачить?}

Відомий німецький математик Леопольд Кронекер якось казав: «Бог створив натуральні числа, решта — справа рук людини».
Числа відіграють дуже важливу роль в нашому житті, тому розглянемо, як можна складати з біт натуральні числа.
Але, на превеликий жаль, точна відповідь на це запитання «Ніяк».
Натуральних чисел нескінченна кількість, тому скільки би ми не брали бітів, все одно з них можна буде скласти лише обмежену кількість різних комбінацій.

Але, якщо підійти до цієї проблеми не з точки зору теорії, а з боку потреб народного господарства, то як часто ми маємо проблему працювати з величезними числами?
Як часто у повсякденному житті ми чуємо про квадрильйони, та секстильйони?

\begin{exercise}
Скільки нулів наприкінці в записі чисел «один квадрильйон» та «один секстильйон»?
\end{exercise}

Тому заслуговує уваги практичний спосіб вирішення проблеми, коли ми кодуємо не усі натуральні числа, а до деякого числа, яке нам здається розумним обмеженням.
Якщо для збереження натурального числа виділити $n$ біт, то, як ми вже знаємо, ми зможемо зберігати $2^n$ різних комбінацій.
Оскільки перше число, яке ми будемо зберігати, це $0$, то останнє число буде $2^n-1$.
Оцінимо тепер різні значення $n$, які часто зустрічаються на практиці.

Припустимо, $n=8$. Як ми дізнаємося пізніше, це байт.
Таким чином ми можемо зберігати числа від $0$ до $255$.
Такий діапазон покриває лише невеличку частину потреб.
Наприклад, у восьмі бітах ми можемо зберігати кількість дітей, пульс (кількість ударів за хвилину), кількість сторінок у зошиті, кількість кнопок у миші, і~т.~д.
Але для зберігання більшості чисел, з якими ми зустрічаємося на практиці, цього буде недостатньо.

\begin{exercise}
Придумайте ще значення, які можна зберігати у восьми бітах
\end{exercise}

У $2010$-х роках була популярна $32$-бітна архітектура.
Цієї кількості біт вистачає для збереження чисел від $0$ до $4~294~967~295$.
Цього вже достатньо для багатьох практичних потреб, будь то заробітна платня або кількість книг у бібліотеці.
Але все ж таки існують й виключення, наприклад борг державного департаменту США, або населення земної кулі.

\begin{exercise}
Для збереження яких ще значень не вистачить $32$-х біт?
\end{exercise}

Тут може виникати запитання, можемо чи ми працювати з $64$-х, або навіть з $128$-ми бітними числами, якщо у нас $32$-бітний процесор.
Відповідь на це запитання проста: можемо, але це буде повільніше.
Бітність процесора означає, над якими числами дії будуть виконуватися за одну операцію.
Щоб працювати з числами з більшою кількістю бітів, нам треба буде написати або використати готові програми, які будуть виконувати потрібні дії але за більшу кількість елементарних операцій.

Зараз більшість комп'ютерів має $64$-бітну архітектуру, таким чином діапазон складає від $0$ до запаморочливого числа $18~446~744~073~709~551~615$, яке вимовляється «18 квінтильйонів, 446 квадрильйона, ...»
Як часто у житті ви оперуєте такими числам? Особисто я не часто.
Цікаво, що це число з'являється у притчі про раджу та винахідника шахів, який у нагороду попросив трохи зерна, одне на першу клітину, два на другу, чотири на третю,~...
На шахівниці усього $64$ клітини, тому  не дивно, що ці числа збіглися.

Але це ще не кінець.
Розробники криптовалюти Ethereum, платформи для смарт-контрактів, вибрали для своєї архітектури $512$ біт.\index{Ethereum}
Цього достатньо, щоб зберігати числа, які складаються зі $150$-ти цифр, а це більше ніж гугол, число $1^{100}$ або одиниця та сто нулів!
Вибір такого числа пояснюється тим, що зробити підтримку для мікротранзакцій з сумами значно менше ніж один цент.
$1$~wei, найдрібніше значення криптовалюти ETH, яким можна оперувати, на момент написання книги коштувало $0.000~000~000~000 002~598$ доларів.
Але головною причиною вибору такого значення був все ж таки технічний момент.
Автори Ethereum вибрали алгоритм хешування, який повертає $512$-бітне число.

Скажемо пару слів про хешування, та чому саме для нього потрібні такі величезні числа.\index{хеш}
Алгоритм хешування полягає у тому, щоб задану послідовність біт перетворити у певне обмежене число, яке називається хешем цієї послідовності.
Хешування є криптографічним, якщо \textit{практично неможливо}\footnote{
  Це означає, що сьогодні ніхто не наблизився до розв'язку цієї задачі.
  Або, якщо використовувати сучасні алгоритми, та усю планету перетворити на велетенський процесор, то потрібні будуть квінтильйони років для розв'язку.
} по хешу знайти послідовність біт, з якого він був згенерований, чи згенерувати дві послідовності, яким буде відповідати один й той самий хеш.
Таким чином, наприклад, дві сторони можуть опублікувати, що вони підписали договір, та надати його хеш.
Тоді ніхто не буде знати, який саме договір підписали сторони.
Але кожна зі сторін, наприклад у разі виникнення спору, може показати у суді договір, який відповідає хешу.
Ця техніка зазвичай дуже важлива для блокчейна.
Але якщо вибрати у якості хешу $32$-бітне число, то можна просто перебрати трохи більше $4$~млрд. різних послідовностей та знайти дві з однаковим хешем.
Чим більше біт, тим складніше перебирати та знаходити слабкі місця у алгоритмі.
Як раз $256$ та $512$-бітні хеші на сьогодні є компромісом між безпекою та швидкодією.

Далі йдуть цифрові підписи та шифрування.
Там компроміс між безпекою та швидкодією приводить нас до $1024$ або $2048$-бітного шифрування.
Але й інколи в деяких країнах у це втручається навіть закон, який обмежує кількість біт, які мають використовуватися для шифрування.
Напевне, щоб влада могла розшифрувати, якщо їй дуже сильно закортить.

Добре, припустимо ми виділили із запасом мільйон біт.
Думаєте цього усім вистачить?
Помиляєтеся, та дуже недооцінюєте математиків!
Вони дійшли до таких чисел, що навіть якщо для виділити усі диски у світі, все рівно їх не вистачить для зберігання навіть одного числа!
Прикладом такого числа є $TREE(3)$ з теореми Крускала\footnote{\kruskalref}.

\begin{summary}
\item Натуральних чисел нескінчена кількість, тому на практиці обмежуються деяким числом, яке, здається, неможливо перебільшити.
\item Чим більше біт використовується, тим більше потреб покривається, але тим повільніші операції. $64$-біт вистачає для більшості потреб.
\item Математики---божевільні!
\end{summary}

\subsection{Як скласти числа з біт?}

Добре, ми трохи обговорили тему, скільки біт треба виділити на числа у разі тієї чи іншої задачі.
Тепер треба вирішити більш практичне запитання: «Яким методом можна скласти числа з біт?» (рис.~\ref{Pic_Num_From_Bits})

\begin{figure}[t]
  \centering
  \input{pic-num-from-bits.tex}
  \caption{Яким саме послідовностям біт мають відповідати числа?}
  \label{Pic_Num_From_Bits}
\end{figure}

Знову, як математики та програмісти, на початку спробуємо розглянути самий елементарний випадок, а саме один єдиний біт.
Отже, у нас $n=1$, у нас є послідовності \bitstr{0} та \bitstr{1}.
Нам треба зіставити цим послідовностям числа $0$ та $1$.
Яким чином це можна зробити?
Сподіваюся, що якщо ви не диверсант, то вибрали природній шлях нуль назвати нулем, а одиницю---одиницею.

Тепер спробуємо розглянути випадок $n=2$.
Тепер ми маємо послідовності \bitstr{00}, \bitstr{01}, \bitstr{10}, \bitstr{11}, та числа $0$, $1$, $2$, $3$.
Тут гарно пригадати властивості звичайних чисел, а саме що до будь-якого числа можна зліва приписати будь яку кількість нулів, воно від цього не зміниться: $42 = 042 = 00042$.
Це дуже зручно на практиці, бо не треба гадати, як число з чотирьох біт перевести у число з восьми бітами: просто дописуємо потрібну кількість нулів.
Таким чином, ми вже маємо, що \bitstr{00} це $0$, а \bitstr{01} це $1$.
Лишилося лише знайти відповідність між \bitstr{10} й \bitstr{11}, ти числами $2$ і $3$.

І знову два способи це зробити: перший, коли $2$ це \bitstr{10}, а $3$ це \bitstr{11}; та другий, коли $2$ це \bitstr{11}, а $3$ це \bitstr{10}.
Якщо придивитися, то ми обидва рази приписуємо зліва одиницю, тут ніякого вибору в нас немає.
Але, якщо не звертати на її увагу, то перший раз буде \bitstr{0}, \bitstr{1}, тобто та послідовність, яку ми вже отримали при $n=1$.
Другий раз ми приписуємо зліва одиницю до \bitstr{1}, \bitstr{0}, тобто ми записали послідовність, яка була при $n=1$, але задом-наперед.
Звичайно, що перша спроба здається нам більш простішою та логічною: менше зайвих рухів.
Так, цей метод дає нам двійкову систему числення, яка й використовується у переважної більшості сучасної електроніки.\index{система числення, двійкова}
Але й зворотній порядок не безглуздий, таким чином утворюється кодування Грея, яка інколи має свої переваги.\index{Грея, кодування}

Сконцентруємося спочатку на двійковій системі числення.
Спробуємо описати більш формально послідовність кроків, як побудувати цю послідовність для будь-якого числа біт.
Коли математики кажуть «більш формально», то це означає, що опис містить менше натяків, котрі кожен може зрозуміти на власний розсуд.\index{формальний опис}
Наприклад, візьмемо послідовність дій з реального життя, наприклад «піди купи молоко».
Більше формальний опис буде: «Вийди з дому, прямуй по вулиці Гоголя на північ, через $200$~метрів, там буде магазин Гастроном, у якому купи молоко~$3.5$\% жиру.»
Зазвичай, написання програм, яке ми мріємо опанувати,  це перекладення побажань користувача на формальну мову програмування.

Якщо опис для вирішення задачі настільки формальний, його може виконати навіть механічний пристрій (читаємо комп'ютер), то ми його називаємо алгоритмом.\index{алгоритм}
У нашому випадку ми отримуємо:

\begin{algorithm}
  \algcaption{Побудова послідовності у двійковій системі числення}
  \alginput{Вже побудована послідовність $A$ для $n$ біт}
  \algoutput{Продовжити послідовність для $n+1$ біт}
  \begin{algsteps}
    \algstep Виписати послідовність $A$.
    \algstep Для кожного елементу щойно виписаної послідовності приписати зліва нуль.
    \algstep Виписати ще раз послідовність $A$.
    \algstep Для кожного елементу щойно виписаної послідовності приписати зліва одиницю.
  \end{algsteps}
  \algsummary{У нас буде виписана послідовність для $n+1$ біт}
\end{algorithm}

Тепер спробуємо розібратися, як працює цей алгоритм.
На початку розглянемо випадок $n=1$, та спробуємо ретельно виконати кожен крок.
Отже, самий початок, нам треба вже побудована послідовність для одного біта.
Ми вже розглядали цей випадок, такою послідовністю буде \bitstr{0}, \bitstr{1}.
Запам'ятали, що це буде наше $A$.

Перший крок полягає у тому, щоб виписати цю послідовність.
Це нескладно, у нас послідовність $A$ складається в двох елементів:
\par\bitstr{~~~~~0~~1}\par
Другий крок---приписати зліва нуль до кожного елементу послідовності.
Що ж, приписуємо:
\par\bitstr{~~~~00~01}\par
Третій крок, нам треба знову виписати послідовність $A$, яка складається з двох елементів.
Виписуємо:
\par\bitstr{~~~~00~01~~0~~1}\par
Четвертий крок---приписати до щойно виписаних двох елементів зліва одиницю.
Робимо й це:
\par\bitstr{~~~~00~01~10~11}\par
Вуаля, ми дійшли до кінця, та ми отримали послідовність з чотирьох елементів \bitstr{00}, \bitstr{01}, \bitstr{10}, \bitstr{11}.
Це й буде послідовність чисел у двійковій системі числення для $n=2$.
Завдання виконано!

\begin{exercise}
А тепер відкладіть цю книгу, та повторіть усі ці кроки самостійно. Перечитайте ще раз, якщо є певні непорозуміння.
\end{exercise}

Тепер розглянемо випадок $n=2$.
Ми щойно побудували двобітові послідовності для двійкової системи числення.
Наступна наша мета це перейти від щойно отриманого результату до трьохбітових послідовностей.
Якщо ретельно виконувати кожен крок нашого алгоритму, ми отримаємо наступні результати після кожного кроку:

\par\bitstr{~~~~~00~~01~~10~~11}\par
\par\bitstr{~~~~000~001~010~011}\par
\par\bitstr{~~~~000~001~010~011~~00~~01~~10~~11}\par
\par\bitstr{~~~~000~001~010~011~100~101~110~111}\par

\begin{exercise}
Виконати наш алгоритм для $n=3$ для отримання чотирьохбітових послідовностей.
\end{exercise}

\begin{exercise}
Нехай загнутий палець відповідає цифрі \bitstr{0}, а відігнутий---цифрі \bitstr{1}.
Спробуйте порахувати на пальцях однієї руки від $0$ до $31$ у двійковій системі числення.
\end{exercise}

Наприкінці декілька слів про кодування Грея.
Пригадаємо, що ми казали, що цей зворотній порядок не безглуздий.
Спробуємо змінити наш алгоритм таким чином, щоб він будував числа у кодуванні Грея.
Як ми казали, другий раз треба виписувати нашу послідовність у зворотньому порядку.
Таким чином, у нашому алгоритмі зміниться лише третій крок:

\begin{algorithm}
  \algcaption{Побудова послідовності біт у кодуванні Грея}
  \alginput{Вже побудована послідовність $A$ для $n$ біт}
  \algoutput{Побудувати послідовність для $n+1$ біт}
  \begin{algsteps}
    \algstep Виписати послідовність $A$, яка у нас уже є
    \algstep Приписати зліва нуль
    \algstep Виписати задом наперед послідовність $A$
    \algstep Приписати зліва одиницю для щойно виписаної послідовності
  \end{algsteps}
\end{algorithm}

Таким чином, для $n=2$ результат виконання алгоритму після кожного кроку буде виглядати наступним чином:
\par\bitstr{~~~~~0~~1}\par
\par\bitstr{~~~~00~01}\par
\par\bitstr{~~~~00~01~~1~~0}\par
\par\bitstr{~~~~00~01~11~10}\par

А це випадок для $n=3$:
\par\bitstr{~~~~~00~~01~~11~~10}\par
\par\bitstr{~~~~000~001~011~010}\par
\par\bitstr{~~~~000~001~011~010~~10~~11~~01~~00}\par
\par\bitstr{~~~~000~001~011~010~110~111~101~100}\par

Єдина складність полягає у тому, щоб не заплутатися та не узяти якийсь результат з алгоритму для двійкової системи числення, або не забути на третьому кроці про слова «задом-наперед».

\begin{exercise}
Побудувати коди Грея для чотирьох біт.
\end{exercise}

Добре, а чим саме корисне кодування Грея?
Це досить специфічне питання більше для загальної освіти, ніж для практичного застосування.
Але, як на мене, цікаве.
Порівняємо, як відбувається перехід від числа $3$ до числа $4$ у двійковій системі числення, та у кодуванні Грея.

\par$3 \to 4$: \bitstr{~~~~~~011} $\to$ \bitstr{100} (двійкова система)
\par$3 \to 4$: \bitstr{~~~~~~010} $\to$ \bitstr{110} (кодування Грея)

Ми бачимо, що у двійковій системі числення кожен біт змінив своє значення.
Самий лівий був \bitstr{1}, а став \bitstr{0}.
Середній також був \bitstr{1} й також став \bitstr{0}.
А самий правий біт, навпаки, був \bitstr{0}, а став \bitstr{1}.

У кодуванні Грея помінявся лише самий правий біт, був \bitstr{0}, а став \bitstr{1}.
Лівий та середній біти на змінилися.
Це є як раз і є корисна властивість кодування Грея: коли ми переходимо до наступного числа, у нас змінюється значення рівно один біту.

\begin{exercise}
Перевірте цю властивість для послідовності трьохбітових кодів Грея: \bitstr{000~001~011~010~110~111~101~100}.
\par Підкресліть ті біти, які змінять своє значення у наступному числі.
\end{exercise}

\begin{figure}[tb]
  \centering
  \input{pic-num2-vs-grey.tex}
  \caption{Прилад, датчики якого повертають значення у (а) двійковому кодуванні; (б) кодуванні Грея.}
  \label{Pic_Device}
\end{figure}

Ця властивість буде нам у нагоді, коли кожен біт це результат окремого вимірювання.
Припустимо, що ми будуємо прилад, який вимірює відстань до деякого об'єкту та повертає $0$, $1$, $2$ або $3$ метри (рис.~\ref{Pic_Device}).

Для двійкової системи (а), датчик, що відповідає за лівий біт, має повертати значення \bitstr{1}, якщо відстань більше за $2$ метри.
А датчик, що відповідає правий біт, має повертати значення \bitstr{1} якщо відстань знаходиться від $1$ до $2$ метрів, або більше ніж $3$ метри.
Проблема полягає у тому, що на практиці, на жаль, неможливо побудувати датчик, який буде повертати точне значення без помилок.

\begin{figure}[t]
  \centering
  \input{pic-num2-error.tex}
  \caption{Проблема зона у приладі, датчики якого повертають значення у двійковому кодуванні.
           Літерою Л позначено датчик, що відповідає за лівий біт, а літерою П---за правий.}
  \label{Pic_DeviceError}
\end{figure}

Давайте поміркуємо, що буде у випадку, коли значення повертаються з помилками.
Припустимо, що у реальному світі датчик, що відповідає за лівий біт (позначимо його Л), повертає значення \bitstr{1} коли відстань більше ніж $1.98$ метри.
А датчик, що відповідає за правий біт (П), буде повертати \bitstr{1} коли відстань потрапляє у діапазон від $1.02$ до $2.01$ метрів, або більше ніж $3.03$ метри.
Що буде відбуватися, коли відстань буде коливатися біля двох метрів?
Відповідь на це дає рис.~\ref{Pic_DeviceError}.
Ми бачимо, що коли відстань до об'єкту потрапляє у діапазон від $1.98$ до $2.01$ метри, наш прилад повертає значення $3$~м, або \bitstr{11} у двійковій системі.
Можна сказати, що це значення «ніяк не пов'язано з реальністю, простіше кажучи «від балди».
Такі проблеми досить важко вирішувати.

\begin{exercise}
Нарисуйте аналог рисунку~\ref{Pic_DeviceError} для кодування Грея на відстані біля $2$~м, та переконайтеся, що там ця проблема не виникає.
\end{exercise}

\begin{exercise}
Нарисуйте аналог рисунку~\ref{Pic_Device} для датчика з трьома бітами.
\end{exercise}

\begin{summary}
\item Числа з бітів можна складати різними способами.
\item Найпоширеніший спосіб це двійкове кодування.
\item Ще один екзотичний спосіб це кодування Грея.
\item Алгоритм це формальна послідовність кроків, для досягнення певної мети.
\item Людина має виконувати алгоритми виключно спинним мозком.
\end{summary}

\begin{exercise}
Це був важкий параграф, де ви могли дізнатися багато нових речей. Тому зараз дуже гарний привід, щоб трохи відпочити та випити свого улюбленого напою.
\end{exercise}

\begin{exercise}
Відпочили? Знову з нуля побудуйте послідовності у двійковій системі числення та у кодування Грея. Нічого не забули?
\end{exercise}

\subsection{Системи числення}

У попередньому параграфі ми дізналися про те, що таке двійкова система числення.
Звичайні числа, на кшталт $42$ та $1024$, це десяткова система числення.\index{система числення, десяткова}
Тобто, дві системи числення вже знаємо.
Тепер настав час узагальнення, поговоримо про системи числення за будь якою основою $n$.\index{основа системи числення}

Але розпочнемо ми з того, що ще раз більш ретельно розглянемо наші знайомі десяткові числа.
Візьмемо, наприклад, число $1024$, та спробуємо розшифрувати його запис.
Можна помітити, що ми маємо на увазі число, яке можна отримати за наступною формулою:
$$ 1024 = 1000 + 20 + 4 $$
Це добре, але спробуємо більш явно виділити наші цифри $1$, $0$, $2$ та $4$, які використовуються в нашому числі:
$$ 1024 = 1 \cdot 1000 + 0 \cdot 100 + 2 \cdot 10 + 4 \cdot 1 $$
Нам лишився невеличкий крок, було б дуже гарно коли б поруч кожної цифри стояла б її позиція.
Сказано---зроблено!
$$ 1024 = 1 \cdot 10^3 + 0 \cdot 10^2 + 2 \cdot 10^1 + 4 \cdot 10^0 $$
Трохи зупинимося та переведемо подих.

Думаю, що навіть читач, не дуже знайомий з математикою, знає що таке ступінь, яка показує скільки разів треба перемножити число на себе, щоб отримати результат.
Наприклад, $10^3=10 \cdot 10 \cdot 10 = 1000$.
За цією логікою досить легко знайти, що $10^1 = 10$, та переконатися у тому що формула $a^1=a$ вірна.

\begin{exercise}
Чому дорівнює $2^8$?
\end{exercise}

Цікавіша відповідь на запитання, чому саме $10^0=1$?
Це усе наслідки простої формули
\begin{equation} a^{m+n} = a^m \cdot a^n \label{FormulaPowerAddition} \end{equation}

Неважко переконатися на прикладах, що ця формула працює: $10^{2+3} = 10^5 = 100~000$, та $10^2 \cdot 10^3 = 100 \cdot 1000 = 100~000$.
Обидва випадки дали нам один й той же результат.
Якщо обидва числа $m$ та $n$ більше нуля, то формула має простий сенс: не важливо у якій послідовності перемножувати числа:
$$ \begin{array}{ccccccc}
2\cdot2\cdot2\cdot2 &=& 2\cdot(2\cdot2\cdot2) &=& (2\cdot2)\cdot(2\cdot2) &=& (2\cdot2\cdot2)\cdot2 \\
2^4 &=& 2^1 \cdot 2^3 &=& 2^2 \cdot 2^2 &=& 2^3 \cdot 2^1
\end{array} $$

А тепер подумаємо, що буде, якщо застосувати цю формулу у випадку, коли $n=0$?
Ліва частина формули спроститься до $a^{m+0} = a^m$.
Права частина не зміниться: $a^m \cdot a^0$.
Отже ми отримали рівність: $a^m = a^m \cdot a^0$, яка може виконуватися лише коли $a^0=1$.

Також ця чарівна формула може нам допомогти з'ясувати, як обчислити $a^{-1}$.
Дійсно, якщо подивитися на вираз $a^{1+(-1)}$, то він буде дорівнювати, одного боку $a^{1-1}=a^0=1$, а з другого $a^1 \cdot a^{-1} = a \cdot a^{-1}$.
Таким чином, ми отримали рівність $1 = a \cdot a^{-1}$, звідки можна обчислити $a^{-1} = 1/a$.
Наприклад, $10^{-1} = 1/10 = 0.1$, аналогічно $10^{-3} = 1/1000 = 0.001$.

\begin{exercise}
Чому буде дорівнювати $2^{-2}$?
\end{exercise}

А тепер дуже цікавий та важливий момент: чому я виписую як отримати формули, а не просто кажу: «запам'ятайте або запишіть, що $a^{-n}=1/a^n$»?
Тому що формули це маячня.
Я навіть припускаю випадок, коли й вам вони більше ніколи у житті не знадобляться.
Але, в програмуванні (як й в математиці) інформації настільки багато, що її неможливо усю запам'ятати.
Тому з цього прикладу треба винести не формули, а суть: у своєму мозку можна побудувати систему, шифр або код, який, коли виникне потреба, дозволить вам або винайти ще раз, або дасть підказку, де та як шукати відповіді.
До речі, дуже схоже, що наша пам'ять як раз й працює таким чином, що зберігає лише ключові моменти, а увесь антураж відтворюється за потребою.
Щоб бути хорошим програмістом, ви маєте це використовувати по максимуму.

\begin{exercise}
Отримайте формулу $a^{-n}=1/a^n$.
\end{exercise}

Зі ступенями розібралися, тепер маємо усе, щоб написати загальну формулу того, як розшифровується запис числа у десятковій системі числення:

\begin{equation}
x = d_{m-1} \cdot 10^{m-1} + ... + d_1 \cdot 10^1 + d_0 \cdot 10^0
\label{FormulaTenNum}
\end{equation}

У цій формулі $m$ це кількість цифр у записі числа, $d_{m-1}$,~...,~$d_1$, $d_0$ це цифри зліва-направо, з яких складається число.

Як працює ця формула? Дуже просто. Візьмемо знайомий приклад $1024$.
Запис числа складається з чотирьох цифр, тобто $m=4$.
Також акуратно виписуємо наші цифри: $d_3=1$, $d_2=0$, $d_1=2$,~$d_0=4$.
Лишилося лише підставити усе в нашу формулу:

$$ 1024 = 1 \cdot 10^3 + 0 \cdot 10^2 + 2 \cdot 10^1 + 4 \cdot 10 ^ 0 = 1000 + 20 + 4 $$

Ми вже це бачили, формула працює!

Рухаємося далі, та спробуємо зрозуміти, яку саму роль відіграє у ній число $10$.
По-перше, при заміні числа ми використовуємо десять цифр, а саме $0$, $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$.
По-друге, кожну цифру ми множимо на десять у ступені, яка відповідає позиції числа.
Добре, спробуємо узагальнити, та замінити $10$ на довільне число $b$:

\begin{equation}
x = d_{n-1} \cdot b^{n-1} + ... + d_1 \cdot b^1 + d_0 \cdot b^0
\label{FormulaBNum}
\end{equation}

Тут $n$ це також кількість цифр у записі числа, $d_0$, $d_1$,~...,~$d_{n-1}$ також цифри, але треба обмовитися, що кожна цифра має бути у діапазоні від $0$ до $b-1$.

Якщо взяти $b=2$, то ми отримаємо двійкову систему обчислення.
Спробуємо погратися з нею!
По-перше, наші цифри дають бути у діапазоні від $0$ до $1$ (бо $b-1=2-1=1$).
Як раз, ми маємо \bitstr{0} та \bitstr{1}.
По-друге, замість числа $b$ будемо використовувати двійку:

\begin{equation}
x = d_{n-1} \cdot 2^{n-1} + ... + d_1 \cdot 2^1 + d_0 \cdot 2^0
\label{FormulaTwoNum}
\end{equation}

\afterpage{\begin{longtable}{cccc}
  \caption{Числа з чотирьох цифр у двійковій системі числення}\\
  Число & Біти та $16$--річна цифра & Число & Біти та $16$--річна цифра\\ \hline
  0 & \bitstr{~0000~~~~~~~0} &  8 & \bitstr{~1000~~~~~~~8} \\
  1 & \bitstr{~0001~~~~~~~1} &  9 & \bitstr{~1001~~~~~~~9} \\
  2 & \bitstr{~0010~~~~~~~2} & 10 & \bitstr{~1010~~~~~~~A} \\
  3 & \bitstr{~0011~~~~~~~3} & 11 & \bitstr{~1011~~~~~~~B} \\
  4 & \bitstr{~0100~~~~~~~4} & 12 & \bitstr{~1100~~~~~~~C} \\
  5 & \bitstr{~0101~~~~~~~5} & 13 & \bitstr{~1101~~~~~~~D} \\
  6 & \bitstr{~0110~~~~~~~6} & 14 & \bitstr{~1110~~~~~~~E} \\
  7 & \bitstr{~0111~~~~~~~7} & 15 & \bitstr{~1111~~~~~~~F} \\
  \label{TableTwoNum}
\end{longtable}}

Тепер перевіримо як це працює.
Якщо ви виконували вправи у попередньому параграфі, то мали б побудувати послідовність чисел у двійковій системі, де кожне число складається з чотирьох цифр.
Результат приведено у таблиці~\ref{TableTwoNum}.
Розглянемо на прикладі числа \bitstr{1010}, та переконаємося, що ми маємо отримати число $10$.
Дійсно $$ 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 0 \cdot 2^0 = 8 + 0 + 2 + 0 = 10 $$
Ми бачимо, що побудована нами двійкова система числення працює аналогічно тому, як десяткова.

\begin{exercise}
Переконайтеся, що числа \bitstr{0111} та \bitstr{1101} відповідають числам $7$ та $13$.
\end{exercise}

Звісно, що числа $2$ та $10$ ніякі не магічні, та ми можемо використовувати будь які інші.
Наприклад, у п'ятирічний системі числення будуть використовуватися цифри $0$, $1$, $2$, $3$, $4$, та показник ступню $5$.
Щоб не заплутатися, ми можемо у якості індексу числа вказувати, у якій системі обчислення воно написане.
Тоді $341_5 = 3 \cdot 5^2 + 4 \cdot 5^1 + 1 \cdot 5^1 = 3 \cdot 25 + 4 \cdot 5 + 1 \cdot 1 = 75 + 20 + 1 = 96$.

\begin{exercise}
Якими числами будуть $42_7$ та $2022_3$?
\end{exercise}

В історії людства була не лише десяткова система числення, але й інші.
У давньому Вавилоні використовувалася $60$--річна система числення.
Майя використовували $20$--річну систему числення.
Не так давно в Англії фунт складався з $12$ шилінгів, а це натяк на $12$--річну систему числення.

А як позначають цифри, якщо їх більше ніж десять?
Сьогодні зазвичай цифри, які менші за $10$, позначають вже знайомими десятковими цифрами від $0$ до $9$.
А цифри, які більше або дорівнюють десяти, означать літерами латинського алфавіту, починаючи з \bitstr{A}.
Так, цифра, яка відповідає числу $10$, це \bitstr{A}, $11$ це \bitstr{B}, $12$ це \bitstr{C} і~т.~д.

При програмуванні, практичне значення має $16$--річна система числення.\index{система числення, $16$--річна}
Цифрами у цій системі числення будуть \bitstr{0}, \bitstr{1}, \bitstr{2}, \bitstr{3}, \bitstr{4}, \bitstr{5}, \bitstr{6}, \bitstr{7}, \bitstr{8}, \bitstr{9}, \bitstr{A}, \bitstr{B}, \bitstr{C}, \bitstr{D}, \bitstr{E}, \bitstr{F}.
Щоб відрізняти $16$--річні цифри від інших, \hexdesc.

\begin{exercise}
Чому дорівнює число \hexstr{5A}?
\end{exercise}

У чому цінність $16$--річної системи числення?
Якщо уважно подивитися на таблицю~\ref{TableTwoNum}, то можна побачити, що кожній групі з чотирьох біт відповідає одна $16$-річна цифра.
Таким чином можна дивитися на $16$--річну систему числення як на скорочений запис двійкової.
Кожен раз, коли нам треба перевести число зі $16$--річної систему у двійкову, ми замість кожної $16$--річної цифри записуємо відповідну послідовність чотирьох біт.
Навпаки, якщо нам треба перевести число у двійковій системи числення до $16$--річної системи, ми, починаючи справа наліво, замінюємо кожні чотири біти на відповідну $16$--річну цифру.

Наприклад, число \hexstr{5A} це, відповідно таблиці, двійкове число \bitstr{0101~1010}.
Якщо, навпаки,  перевести число \bitstr{1011010} до $16$--річної системи, то ми справа замінимо \bitstr{1010} на \bitstr{A}, потім \bitstr{101} на \bitstr{5}, отримуючи у результаті \hexstr{5A}.

\begin{exercise}
Переведіть до двійкової системи числення число \hexstr{FACE}?
\end{exercise}

\begin{exercise}
Переведіть до $16$--річної системи числення \bitstr{1101000000001}?
\end{exercise}

Можливо серед читачів є такі, що у цей час подумають про те, що системи числення це не просто, а дуже просто.
Спробую їх трошки здивувати.
Система числення описується цифрами та основою.
Наприклад, у трійковій системі числення використовуються числа $0$, $1$, $2$ та основа $3$.
Ми зазвичай вибирали для основи $n$ цифри від $0$ до $n-1$, і це було дуже зручно.
Але це не обов'язково.
Наприклад, ми можемо вибрати показник ступеню $3$ та цифри $0$, $1$ та $-1$.
Цифру $-1$, яка виводить нас зі зони комфорту, будемо позначати $\hat 1$.
Таким чином, число $\hat 101$ буде дорівнювати:
$$
  \hat 101 = (-1) \cdot 3^2 + 0 \cdot 3^1 + 1 \cdot 3^0 = (-1) \cdot 9 + 0 + 1 \cdot 1 = -9 + 1 = -8
$$

Така система числення називається збалансованою трійковою.
Її особливість полягає у тому, що можна записувати не лише додатні числа, але й від'ємні.

\begin{exercise}
Чому дорівнює число $1\hat1\hat1\hat1$ у трійковій збалансованій системі числення?
\end{exercise}

Також у якості основи можна брати зовсім дивні числа, наприклад комплексне число $1-i$, де $i=\sqrt{1}$ та цифри \bitstr{0} та \bitstr{1}.
За допомогою цієї системи числення можна будь яке число на комплексній площині записати через послідовність нулів та одиниць.
Чи не диво?

\begin{summary}
\item Усе запам'ятати неможливо.
\item Намагайтеся будувати моделі, ставити якорі, які будуть вам допомагати менше запам'ятовувати, та більше знаходити або відтворювати за потребою.
\item Можна будувати різні системи числення, які складаються з основи та цифр.
\item $16$--річна система числення це скорочення двійкової.
\end{summary}

\printindex
\end{document}
