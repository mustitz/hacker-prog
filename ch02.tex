\chapter{Букви та рисочки}

Я уявляю свого читача, який зараз відкрив термінал, розгорнув його на весь екран та збирається з думками.
Майже увесь екран чорний, лише у куточку виведено запрошення та блимає курсор.
Цей читач вдивляється в цю пустелю, у цей войд, там задається питаннями:
«Нащо я сюди зайшов?
Як тут не пропасти?
Навіщо це мені треба???»

Можливо навпаки, хтось розгорнув на увесь монітор білий екран терміналу у Mac~OS, та читає в нетерплячці:
«Дайте мені завдання!
Зараз швидко розберуся, та піду рухатися далі!»

Здорова оцінка ще ніколи в IT не заважала, побоювання першого читача обґрунтовані.
Тому ми почнемо цю главу з мотиваційного параграфу, а саме з описом переваг, який надає командний рядок.

\vfill
\pagebreak

\section{Мотивація}

Командний рядок виглядає ворожим оточенням для непідготовленого користувача.
Усе незвично, усе лякає, з чого починати?
Звісно що з мотивації, бо це одна з головних речей у навчанні.
Коли ви розумієте, навіщо ви це робите, які цілі досягаєте, коли бачите світло наприкінці тунелю, то й рухатися уперед значно легше.
А коли ви кружляєте у темряві без гадки про те, чого сподіваєтеся знайти, то скільки ви можете протриматися?
Особисто я недовго.

Але ворога треба знати у лице, тому для початку спробуємо найти переваги, які є у графічному інтерфейсі користувача (Graphical User Interface, або GUI).\index{GUI}
Головне, що дає GUI, це розуміння того, які дії ми можемо виконати.
Перед нами є меню, де ви приблизно знаєте, де шукати потрібні операції.
Наприклад, вихід з програми зазвичай у меню «File», а там за обставинами це може бути «Exit» або «Quit».
Якщо ви хочете зробити дію з якимось елементом, що можна спробувати викликати контекстне меню через натискання правої кнопки миші.
Так, інколи потрібний функціонал дуже сильно прихований, інколи його переносять з одного місця на інше у новій версії продукту, але у цілому це працює.

У командному рядку нам треба набирати команди.
Навіть для типових команд можуть існувати багатого різних можливих варіантів.
Наприклад, інколи, щоб вийти з програми, нам треба ввести \cmdd{exit}, а інколи це \cmdd{quit}.
Для видалення можуть використовуватися такі команди, як \cmdd{remove}, \cmdd{delete}, \cmdd{erase}, або, навіть, скорочення \cmdd{rm} та \cmdd{del}.
Той факт, що треба пам'ятати, яку саме команду треба вводити в тій чи іншій програмі, трохи напружує---треба читати мануали, що більшість користувачів, м'яко кажучи, не полюбляє.
Можливо, коли вам треба один раз на рік, два рази на Пасху щось виправити у зображенні, то дійсно краще запустити графічний редактор, у якому ви зможете знайти необхідні дії без того, щоб ритися у документації.
Але, якщо ви збираєтеся йти у програмування, то хочеш не хочеш---мусиш мати звичку читати документацію.
Тому, як на мене, до цього краще потроху звикати, шкідливою така звичка 100\% не буде.

А тепер поговоримо про переваги командного рядку, та чому багато розробників та системних адміністраторів його полюбляють.
Розглянемо на конкретному прикладі зміни атрибутів файлу.
У GUI я маю виконати наступну послідовність дій: відкрити програму перегляду файлової системи, знайти файл \file{install.sh}, вибрати його, викликати контекстне меню, там «Властивості», далі перейти на вкладику «Доступ», та виставити галочку «Дозволити виконання як програми».
У командному рядку треба набрати та виконати \cmdd{chmod +x install.sh}.

Що відрізняється?
По-перше, це кількість тексту, який описує необхідні дії.
Щоб описати послідовність дій у GUI ми написали невеличке оповідання.
Але проблема не тільки у кількості слів, але й у тому, наскільки повний цей опис.
У разі командного рядку ми маємо команду, яка виглядає крізь однаково, яку досить легко набрати, або, ще краще, скопіювати, та виконати.
Якщо брати випадок GUI, то різні версії програми можуть мати різні назви (як ми пам'ятаємо, це не суттєво для користувача, бо він зазвичай бачить усі альтернативи та може вибрати відповідну).
Різні версії програмного забезпечення можуть перевпорядкувати розташування елементів, що призводить ти ситуації, коли ти пам'ятаєш, що ця функція має бути, але її знову розшукати.
Також програми можуть мати різні налаштування, що призводить до того, що одна й та сама послідовність дій може призводити до різних результатів.
Ну і... спробуйте нагуглити \google{chmod +x}, та придумайте відповідний запит для GUI застосунку.

\begin{exercise}
Перевірте видачу Google за запитом \google{chmod +x}, та спробуйте продивитися декілька результатів, які вас зацікавлять.
\end{exercise}

По-друге, це звіти про помилки.
Наприклад, інколи спроба виконання команди \cmdd{chmod +x install.sh} може призвести до помилки\footnote{
Зверніть увагу, що ми отримали повідомлення на англійській мові.
\todo{reference to intro}
}:

\begin{Verbatim}[fontsize=\footnotesize]
$ chmod +x install.sh
chmod: changing permissions of 'install.sh': Operation not permitted
\end{Verbatim}

Але, ми принаймні спробували виконати команду, та отримали повідомлення, чому саме ця дія не може бути виконана.
На українську мову це повідомлення можна перекласти як «заміна прав для файлу \file{install.sh}: операція не дозволена».
Ми можемо загуглити\footnote{Наприклад, \google{chmod Operation not permitted}} чому саме ця операція не може бути виконана.
У GUI часто ми можемо побачити, що певні дії нам недоступні, потрібний нам прапорець сірий.
Але ніякої підказки, чому саме вони недоступні, зазвичай немає.

А чи бувало у вас таке, що ви щось робили давно, але лише один раз,
хтось вам підказав послідовність дій, і ви вже забули як?
Чи траплялося, що ви знайшли рішення складної проблеми,
але через місяць вже не пам'ятаєте, що саме робили?
У командному рядку є чудова можливість---історія команд.
Усі команди, які ви виконували, зберігаються, і до них можна повернутися.
Можна переглянути історію за допомогою команди \cmdd{history}.
Це особистий записничок усіх ваших дій, який ведеться автоматично.
Спробуйте уявити таку функціональність у GUI.
Можна зберігати відео з екрана, але це гігабайти інформації,
плюс спробуйте потім там щось знайти!

Завжди корисно, а особливо коли ви перші дні на новій роботі
й треба багато чому навчитися, вести свій особистий записничок.
Неважливо, чи ви працюєте у GUI, чи у командному рядку.
Але у разі GUI нам треба писати купу тексту на кшталт
«відкрити меню Правка, потім Налаштування, вкладка Додатково, прапорець біля опції XYZ».
У командному рядку достатньо просто скопіювати\footnote{
Тут може чекати невеличка неприємність, бо сполучення \keys{\ctrl}~+~\keys{C},
до якого звикла переважна більшість користувачів, скоріше за все не буде працювати.
Причина полягає у тому, що термінали з'явилися задовго до виникнення буферу обміну,
тому ця комбінація клавіш використовувалася для іншої задачі.
Але має працювати клік колесиком (або клік правою клавішею) миші,
або, наприклад, \keys{\shift}~+~\keys{Ins}.
} корисну команду з коротким коментарем.
А коли треба звернутися до колеги за допомогою,
зазвичай команда набагато інформативніша за скріншот.

У часи, коли LLM стали невід'ємною частиною нашого життя,
використання командного рядку отримало ще одну перевагу.
Коли ви запитуєте ChatGPT або Claude «як зробити X у командному рядку»,
відповідь зазвичай містить декілька готових команд, яку можна скопіювати та виконати.
Текст це рідна мова для LLM.
Не зважаючи на те, що LLM може також описати послідовність дій у GUI,
працювати з текстом команд простіше.
Ми можемо легко задати уточнювальні питання,
запропонувати змінити частину команди,
попросити пояснити окремі параметри.
AI може швидко модифікувати команду під ваші потреби---замінити назву файлу,
додати додаткові опції, поєднати з іншими командами.

\begin{exercise}
Запитайте у ChatGPT або Claude, як знайти усі файли з розширенням \file{.txt}
у поточній папці за допомогою командного рядку.
Далі попросіть виключити з пошуку директорію \file{.git}.
\end{exercise}

Добре, ліричний відступ закінчено.
Сподіваюся, цього достатньо, щоб у вас виникло бажання
спробувати командний рядок та оцінити його переваги на власному досвіді.
Рухаємося далі.

\begin{summary}
\item Командний рядок це круто!
\item GUI що добре для чогось одноразового, але погано для автоматизації повторюваних дії.
\item Для LLM рідна мова це тексти.
\end{summary}

\section{Приручаємо термінал}

Зробуємо почати нашу першу сесію в терміналі.
Не важливо, як ви його запустили.
Це може бути SSH-сесія, це може бути запуск терміналу в самій Linux, або навіть запуск docker-контейнера.
Але сподіваюся, що ви це зробили.
Якщо ж ви не знаєте як, то вам треба \TODO{подивитися ???}.

Добре, ви запустили термінал.
Що тепер?
Мушу признатися, що я---фанат терміналу.
Тому моя мрія---зробити термінал вашим другом,
щоб ви спробували його можливості,
щоб ви відчули його міць,
щоб ви зрозуміли його досконалість,
щоб після цього ви не захотіли повертатися до GUI.
Тому я не просто хочу розповісти, які команди треба вводити.
Я хочу розказати, як це робити зручно.
Розпочнемо нашу першу ознайомлювальну сесію.

Що ви бачите?
І тут виникає проблема №1: в Linux налаштувати можна все що завгодно.
Що означає, що побачити ви можете будь-що.
Вгадати шансів не більше ніж у спортлото!
Але не панікуйте!
Спробуємо у цьому розібратися.
На більшості систем це текст привітання, який називається повідомлення дня, MOTD (Message of the Day).
Але його може й не бути.
А внизу---запрошення командного рядку.

На рис.~\ref{Terminal_Greeting} показано те, що бачу я, коли заходжу по SSH на мій Funtoo контейнер.
Це 11 рядків нашого MOTD, повідомлення дня, де можна дізнатися трохи технічної інформації:
про систему, версію, дату релізу, контакти розробників, сайти тощо.
А ось останній рядок нас буде цікавити набагато більше:

\texttt{\textcolor{termuser}{cat@mustitz}~\textcolor{termdir}{\textasciitilde~\$}}

Це і є запрошення, за яким після знака долара блимає курсор, а значить система чекає на мої команди!

\begin{figure}[tb]
 \centering
 \begin{Verbatim}[fontsize=\footnotesize,frame=single,commandchars=\\\{\}]
>>> Release:                      lxd-intel64-westmere-funtoo-current-2018-07-10
>>> Version:                      2018-07-10
>>> Created by:                   Daniel Robbins <drobbins@funtoo.org>

>>> Send suggestions, improvements, bug reports relating to...

>>> This release:                 Daniel Robbins <drobbins@funtoo.org>
>>> Funtoo Linux (general):       Funtoo Linux (http://www.funtoo.org)
>>> Gentoo Linux (general):       Gentoo Linux (http://www.gentoo.org)

NOTE: This message can be removed by deleting /etc/motd.

\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
 \end{Verbatim}
 \caption{Початковий екран терміналу в Funtoo Linux контейнері.}
 \label{Terminal_Greeting}
\end{figure}

\begin{exercise}
Подивіться уважно на екран вашого терміналу.
Чи є там текст привітання?
Якщо так, то прочитайте його хоча б раз у житті---щиро сподіваюся,
що у вас ще буде достатньо можливостей його ігнорувати.
\end{exercise}

Тепер перейдемо до запрошення командного рядку. \TODO{промпт}
Давайте розберемо моє запрошення:

\texttt{\textcolor{termuser}{cat@mustitz}~\textcolor{termdir}{\textasciitilde~\$}}

Спочатку йде \texttt{cat}---це ім'я користувача\footnote{
Не думайте, що я котик, це скорочення від category,
і слово категорія тут не в звичайному розумінні,
а category theory, розділ математики.
Під цим користувачем я програмую на Haskell, Idris, Agda, Coq
та інші функціональні штучки, але це ще занадто складно для мене.
Коли розберуся---обов'язково напишу книжку про це.
}.

Далі равлик \chr @, який працює як розділювач між назвою користувача
та назвою хоста---місця, де цей користувач зареєстрований.
У нашому разі \texttt{mustitz}---це просто ім'я мого комп'ютера.

Далі йде блакитненька тильдочка \file{\textasciitilde}, це поточна директорія.
Командний рядок чимось нагадує переглядач файлів, як Explorer у Windows чи Finder у MacOS:
ми також мандруємо з директорії до директорії.
Тому нам важливо знати, де ми знаходимося.
Саме тому поточна директорія це частина запрошення.
Символ тільди \chr\textasciitilde це скорочення для домашньої директорії,
але про це ми більше дізнаємося в наступному розділі.

Нарешті долар \chr\$ знову нагадування нам,
що ми звичайний смертний з обмеженими правами.

Якщо ж зайти з правами адміністратора, то запрошення може стати:

\texttt{\textcolor{termroot}{cat}~\textcolor{termdir}{/home/mustitz \#}}

Усе майже те саме, але замість тільдочки бачимо повний шлях,
а символ решітки \chr\# означає суперкористувача.
Також бачимо, що ім'я користувача виведено червоним, що нагадує суперсилу.
Будьте обережні!
Також, треба відмітити, що немає імені хоста, і таке теж буває.
Ще більше прикладів запрощеннь можна знайти в наступній вправі:

\begin{exercise}
Спробуйте здогадатися про особливості кожного запрошення:

\begin{tabular}{@{\hspace{1em}}p{0.33em}l@{}}
a) & \texttt{\textcolor{termroot}{root@google.com}~\textcolor{termdir}{/var/log~\#}} \\
б) & \texttt{john@macbook-pro Documents \%} \\
в) & \texttt{(venv)~\textcolor{termuser}{alice@ubuntu}:\textcolor{termdir}{\textasciitilde/myproject}\$} \\
г) & \texttt{[21:23:15]~\textcolor{termuser}{dev@server}~\textcolor{termdir}{/opt/app}~\$} \\
д) & \texttt{user@container-da4f22~/app~\$} \\
е) & \texttt{[nix-shell:\textcolor{termdir}{\textasciitilde/project}]\$} \\
є) & \texttt{\textcolor{termuser}{kate@DESKTOP-KW23W9}~\textcolor{termmingw}{MINGW64}:~\textcolor{termdir}{\textasciitilde/Documents/xonix}~\textcolor{termgitbranch}{(master)}} \\
   & \texttt{\$} \\
\end{tabular}

\end{exercise}

\medskip

Ну що, ми розібралися з запрошенням.
Тепер спробуємо вводити команди.
Тут поки що нічого складного:
просто набираємо текст, ніби-то у звичайнісінькому текстовому полі.

\texttt{\textcolor{termuser}{cat@mustitz}~\textcolor{termdir}{\textasciitilde~\$}}

Ми вже казали, що командний рядок замінює переглядач файлів.
Ми бачимо, що ми в поточній домашній директорії, по-англійські home directory.
Home читається як «хоум», тому у програмерському сленгу домашня директорія інколи називається співзвучним «хом'як».

Отже, ми знаходимося у хом'яку.
Але, на відміну від переглядача файлів, ми не бачимо його вміст.
Щоб це зробити, нам треба ввести нашу першу команду: \cmdd{ls}.
Набрати її досить просто, треба послідовно натиснути \keys{l}, потім \keys{s}, та \keys{\return}.
Якщо ми зуміли помилитися при цьому,
то завжди можна видалити останні хибні символи звичайним чином через \keys{\backspace} та спробувати знову.

Отже, я впорався ввести команду без помилок.
І що побачив?

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} ls
\textcolor{termdir}{labs  local  projects  sources}
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Що це означає?
По синьому кольору можна здогадатися,
що у хом'яку чотири директорії: \file{labs}, \file{local}, \file{projects}, \file{sources}.
Також ми бачимо нове запрошення,
що означає, що команда відпрацювала
та система готова виконувати наступну нашу забаганку.

Також не виключено, що ви не побачите й жодного рядка:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{avs@avs-home}:\textcolor{termdir}{\textasciitilde}\$ ls
\textcolor{termuser}{avs@avs-home}:\textcolor{termdir}{\textasciitilde}\$
\end{Verbatim}

Але ви бачите новий промпт, тобто система команду відпрацювала.
Директорія порожня, друкувати нічого, тому нічого не друкуємо.

Тут я хочу вставити ремарку про філософію Unix.
Один з канонів цієї філософії:

\begin{quote}
\textit{Якщо програмі нічого друкувати, вона нічого не має друкувати.}
\end{quote}

Існує легенда, що цей принцип виник ще у ті стародавні часи, коли вивід надсилався на принтер,
і менше повідомлень означало економію на папері та чорнилах.
Одна з переваг цього підходу це спрощення автоматизації, але про це пізніше.
Поки що треба запам'ятати: коли програма мовчить, це означає, що все добре,
а коли щось друкує---треба звернути увагу.

Звісно, що це сервер, там взагалі зазвичай нічого зайвого не створюється.
Але, коли я запущу на домашньому десктопі, я побачу щось на кшталт:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{avs@avs-home}:\textcolor{termdir}{\textasciitilde}\$ ls
 \textcolor{termdir}{Chess}                      ghcup.sh
 \textcolor{termdir}{Desktop}                    halif.txt
 \textcolor{termdir}{Documents                  journal}
 \textcolor{termdir}{Downloads                  labs}
 \textcolor{termdir}{Music}                      pawn.txt
 \textcolor{termdir}{Pictures}                   pdfs.txt
 \textcolor{termdir}{Public                     projects}
 \textcolor{termdir}{Streams                    sandbox}
 \textcolor{termdir}{Templates                  snap}
 \textcolor{termdir}{VBox                       sources}
 \textcolor{termdir}{Videos}                     team.txt
 \textcolor{termdir}{'VirtualBox VMs'}           test.cpp
\textcolor{termuser}{avs@avs-home}:\textcolor{termdir}{\textasciitilde}\$
\end{Verbatim}

Тут ми бачимо купу файлів та директорій.
Більшість директорій, таких як \file{Documents}, \file{Downloads}, \file{Music},
система люб'язно створила для мене.
Видаляти мені їх стрьомно, а класти туди нічого, тому живуть пустенькі.

Окремо треба звернути увагу на \file{'VirtualBox VMs'}.
Апострофи тут не є частиною назви директорії.
Справжня назва---\file{VirtualBox VMs} (з прогаликом).
Апострофи додала надрукувала команда \cmdd{ls},
щоб показати, що у назві є спеціальний символ---прогалик.

Можливо користувачам і подобається називати директорії з прогаликами, краса,
але у програмуванні це постійній головний біль!
В командному рядку та мовах програмування прогалик зазвичай розділяє
окремі елементи: команди, параметри, ідентифікатори.
Тому такі назви це постійні танці з бубном навколо.
Засуджую.

Вихід тут або використовувати підкреслення, або дефіси, або CamelCase,
коли слова пишуть разом, але кожне нове слово починають з великої літери\footnote{
Назва походить від того, що великі літери нагадують горби верблюда.
}.
Наприклад, \file{VirtualBox VMs} можна в Unix стилі назвати як
\file{VirtualBox\_VMs}, \file{VirtualBox-VMs}, або \file{VirtualBoxVMs}.

\begin{exercise}
Запропонуйте альтернативні назви без прогаликів для директорій:
\file{My Documents}, \file{Program Files}, \file{New Folder}.
\end{exercise}

\medskip

Байдуже, чи є у нас щось в хом'яку, чи він порожній,
але гарно не мішати наші експерименти з тим що є.
Тому створимо для них окрему директорію з іменем \file{terminal-experiments-119}
(сподіваюся такого імені у вашому хом'яку немає).

Для створення директорії використовується команда \cmdd{mkdir},
що є скороченням від англійського "make directory" (створити директорію).
Такі скорочення типові для команд у світі Unix.
Знову таки є легенда, що це пов'язано з тими стародавніми часами,
коли треба було економити на кожному натисканні клавіші.
Телетайпи працювали повільно, швидкість передачі даних вимірювалася бодами,
а довші команди означали більше часу на очікування.

Так чи інакше, до цих команд вже звикли, тому треба просто їх запам'ятати.
А якщо у вас погана пам'ять, то надрукуйте собі шпаргалку.

Набираємо нашу команду:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} mkdir terminal-experiments-119
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Знову команда виконалася мовчки.
Це гарний знак, що означає, що директорія створена.
Якщо ви дуже нефартовий, то може статися так,
що директорія з таким іменем уже існує,
або у вас немає прав, або диск переповнений.
У цьому разі ви можете побачити текст помилки, інколи досить езотеричний.
Особисто мені, як ви бачите, пофартило, сподіваюся що і вам також!

Але, оскільки помилка таки може трапитися, було б добре на неї подивитися.
Це проблема багатьох посібників, що там описується лише оптимістичний сценарій.
Ви крокуєте ним, потім бачите першу ж помилку, яка вас вводить в ступор.
Що ж, спробуємо помилитися навмисне.
Як?
Створити ще одну директорію з тим самим іменем.
Відмінно!

Але не спішіть перенабирати команду \cmdd{mkdir bla-bla-bla}.
Термінал живе вже більше піввіку, тому люди давно додали туди певні зручності.
Команду ми вже вводили, вона є у списку історії.
Ми можемо по ньому просто прогулятися, але й довго гуляти не треба,
відразу після того, як ми натиснемо стрілку вгору \keys{\arrowkeyup},
з'явиться наша команда \cmdd{mkdir}!
Трохи звикнемо, та ще раз натиснемо \keys{\arrowkeyup}, маємо побачити команду \cmdd{ls},
яку ми вводили до \cmdd{mkdir}.
Мушу сказати, що деякі програмісти (такі як я) настільки лінині,
що готові натискати десятки разів стрілку вгору,
аби тільки дістатися до команди \cmdd{ls}, тільки щоб її не набирати ручками.
Але нам зараз \cmdd{ls} не треба, натискаємо стрілку вниз \keys{\arrowkeydown},
та повертаємося до нашого \cmdd{mkdir}.
Натискаємо \keys{\return} і бачимо:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} mkdir terminal-experiments-119
mkdir: cannot create directory 'terminal-experiments-119': File exists
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Усе пройшло за планом!
Промпт показує нам, що команда виконалася.
Але не тихесенько зробила свою справу, а з криком душі, який можна перекласти так:
«не можу створити директорію \file{terminal-experiments-119}, бо вона вже існує».

Сподіваюся, з часом ви звикните до того, що команди успішно виконуються мовчки,
та вас буде тригерити кожного разу, коли будете бачити вивід на екран.

Цікаво, що команда \cmdd{mkdir} може створювати декілька директорій одночасно.
Наприклад, команда \cmdd{mkdir Program Files} створила б дві директорії: \file{Program} та \file{Files}.
Ті, хто працював у Windows, відразу помітять засаду!
Напевно ми би хотіли створити одну директорію з назвою \file{Program Files},
але система сприйняла прогалик як розділювач між параметрами.

Якщо нам дійсно треба створити директорію з прогаликом,
то треба брати назву в апострофи, як ми бачили при виводі \cmdd{ls}.
Але не хочу поширювати дурні практики.

Добре, директорії ми створили, тепер нам би в неї перейти.
Для цього є команда \cmdd{cd} з параметром імені директорії.
Але не спішіть вводити \cmdd{cd terminal-experiments-119}!
Це дуже довго, а на більшості систем працює автодоповнення.
Вам треба лише набрати \cmdd{cd ter} та натиснути \keys{\tab}.
У мене відразу з'явилася вся команда: \cmdd{cd terminal-experiments-119}.
Натиснув \keys{\return} і готово:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~/terminal-experiments-119 $}
\end{Verbatim}

Я вже в директорії, про що свідчить зміна у запрошенні:
замість тільки тільди \file{\textasciitilde} тепер бачимо \file{\textasciitilde/terminal-experiments-119}.

Але знову зосередимося на тому, що може піти не так.
Припустимо, що автодоповлення не спрацювало.
Як діяти тоді?
Треба набрати команду повністю, але ми не хочемо й не будемо!
Спробуємо обійти засаду.

Спочатку виконаємо команду \cmdd{ls \textasciitilde}.
На відміну від попереднього \cmdd{ls}, ця команда йде з параметром імені директорії,
вміст якої ми хочемо надрукувати.
Це тільда, як ми пам'ятаємо, це і є домашня директорія.
Ця команда відпрацює правильно, байдуже чи ми перейшли до щойно створеної директорії, чи зафейлилися.
У будь-якому разі \cmdd{ls \textasciitilde} надрукує зміст хом'яка,
й там має бути наша \file{terminal-experiments-119}.

Тепер спробуємо написати команду \cmdd{cd}, щоб вона виконалася з будь-якої поточної директорії.
Для цього наберемо \cmdd{cd \textasciitilde/}, i... нам лишилося вставити нашу довгу назву.
Пам'ятаємо, ми щойно надрукували зміст хом'яка, тому наша довга назва має бути на екрані.
Виділяємо мишкою та натискаємо колесико.
Якщо не спрацювало, то можна спробувати праву кнопку.
Якщо не спрацювало, то тоді новини неприємні---треба питати LLM, як у вашому терміналі вставити виділений текст.
Сподіваюся, він підкаже, бо без цього праця в терміналі милою не буде.

І ось, ви бачите нарешті \cmdd{cd \textasciitilde/terminal-experiments-119},
тепер \keys{\return} і ми перейшли до щойно створеної директорії,
або хитрим чином лишилися там, де були:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~/terminal-experiments-119 $} cd ~/terminal-experiments-119
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~/terminal-experiments-119 $}
\end{Verbatim}

Добре, в директорію ми перейшли.
А що якщо будуть конфлікти при автодоповненні?
Для початку пригадаємо, як створювати декілька директорій одночасно.

\begin{exercise}
Створіть директорії \file{files1}, \file{files2}, \file{files3} однією командою.
\end{exercise}

І тепер набираємо \cmdd{cd f} та натискаємо \keys{\tab}.
Бачимо, що \cmdd{cd f} перетворилося на \cmdd{cd files}.
Інколи навіть при цьому буде тихесеньке бікання.
Система вставила \file{iles}, бо інших варіантів немає.
А от далі може були \file{1}, \file{2} або \file{3}, от вона й трохи розгублена.

Натискаємо \keys{\tab} два рази поспіль, як подвійний клік мишкою і бачимо:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~/terminal-experiments-119 $} cd files
files1/ files2/ files3/
\end{Verbatim}

Система підказує, з чого вибирати.
Припустимо, нас цікавить \file{files3}.
Натискаємо \keys{3} потім знову \keys{\tab}, маємо: \cmdd{cd files3/}

Команда готова до виконання.
Але конфлікт ми проемулювали, потренувалися.
Переходити в цю директорію нам необов'язково.
Тому натискаємо \keys{\ctrl+U} щоб видалити усе від початки команди до курсора,
потім можливо \keys{\ctrl+K}, якщо там щось лишилося, й рухаємося далі.

\begin{exercise}
Потренуйтеся в редагуванні командного рядку.
Що роблять наступні комбінації клавіш:

\keys{\ctrl+A} та \keys{\ctrl+E}
\keys{\ctrl+U} та \keys{\ctrl+K}
\keys{\ctrl+W}
та \keys{\ctrl+\arrowkeyleft}?

Спробуйте набрати довгу команду і поекспериментувати з цими клавішами.
Які з них вам здаються найкориснішими?
\end{exercise}

Ну що, ми дізналися багато зручного при роботі з терміналом.
Але саму бомбу я лишив на останнє.
Так, ми можемо гортати історію стрілочками,
але часто нам треба дуже багато тицяти, щоб дійти до потрібної команди.
Чи є альтернативи?  Звісно!
Є зворотний пошук по історії команд.
Ми можемо набирати частину команди,
а система знайде останню команду з історії, яка містить цю послідовність.

Як це працює?

Натискаємо \keys{\ctrl+R} і бачимо:
\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
(reverse-i-search)`':
\end{Verbatim}

Набираємо \cmdd{119}.
Система знайшла нашу останню команду, де зустрічалося {\texttt 119}:
\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
(reverse-i-search)`119': cd ~/terminal-experiments-119
\end{Verbatim}

Тепер нам треба лише натиснути \keys{\return} щоб її виконати.
Або ми можемо натиснути \keys{\arrowkeyright} щоб її відредагувати.

\begin{exercise}
Пригадайте команди, які ми вводили та спробуйте їх ефективно знайти через \keys{\ctrl+R}.
\end{exercise}

\begin{summary}
\item Уникайте прогаликів у назвах файлів та директорій!!!
\item Термінал пропонує набір зручних інструментів (історія, автодоповнення), щоб зменшити кількість набираємого тексту.
\item \keys{\ctrl+R} це бомба!
\end{summary}

\section{Файли та директорії}

Коли я починав програмувати, на персональних комп'ютерах панував DOS.
На моніторах часто можна було бачити дві блакитні панельки програми Norton Commander,
яка дозволяла зручно копіювати, переміщувати та редагувати файли.
То була основа основ: прийшов працювати---треба скопіювати файли з дискети на жорсткий диск.
Закінчив роботу---треба зберегти результат.
Хочеш запустити програму?  Треба її знайти.
Саме тому, що операції з файлами були настільки важливими, почали з'являтися конкуренти.
Volkov Commander займав менше місця в пам'яті.
Dos Navigator умів майже усе.
Навіть після появи Windows та GUI багато хто вважав вбудований File Explorer незручним,
тому залишалися популярними Far Manager та Total Commander,
бо користувачі прагнули максимальної зручності.

В епоху DOS командний рядок був незручним для роботи з файлами,
тому всі намагалися вийти з нього якнайшвидше та запустити свою улюблену програму.
Сьогодні ситуація кардинально змінилася.
В епоху Android та особливо iOS інколи взагалі важко здогадатися, що десь там є файлова система.
Користувачі працюють з додатками, не замислюючись про те, де зберігаються їхні фото чи документи.

Але, якщо ви хочете програмувати---від файлової системи не втекти.
І хоча в Unix існує Midnight Commander---прямий нащадок Norton Commander---ним користуються значно рідше.
Виявляється, що командний рядок для роботи з файлами може бути зручнішим за графічні аналоги!
Хто б мені сказав про це у часи DOS---розсміявся б в обличчя.

\begin{exercise}
Спробуйте пригадати, якими файловими менеджерами ви користувалися.
Скільки пригадали?
\end{exercise}

Ну що ж, починаємо нашу мандрівку файловою системою!
Запускаємо нову сесію терміналу та дивимося на наш командний рядок.
Я бачу знайоме запрошення, яке говорить мені, що я знаходжуся у домашній директорії.
Але тільда це лише скорочення, а де ж насправді розташована ця директорія?
Щоб це з'ясувати, скористаємося командою \cmdd{pwd} (print working directory---надрукувати робочу директорію):

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} pwd
/home/cat
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Ось тепер ми бачимо повний шлях до поточної директорії: \file{/home/cat}.
Давайте розберемо цей шлях детальніше.
Легко побачити, що шлях містить дві компоненти: \file{home} та \file{cat},
а у якості розділювача використовується символ \chr{/}, який називається «слеш» (slash).
Назва «слеш» це типографський термін, який позначає косу риску.
Вона використовувалася для розділення тексту або позначення альтернатив (наприклад, "and/or").

У 1960--70-х роках, разом із розвитком комп'ютерних систем,
з'являється символ косої риски, яка нахилена у зворотну сторону.
Цей символ \chr{\textbackslash} отримав назву «зворотний слеш».
Відповідно, замість «слеш» інколи вживають більш уточнювальне «прямий слеш».
Так от, у DOS та Windows у якості розділювача використовується саме зворотний слеш.
Це створює додаткові граблі для розробників,
чиї програми мають працювати одночасно і в Windows, і в Linux,
бо треба визначити, в якій операційній системі наш код виконується,
а потім вибрати відповідний слеш.
Існує популярна байка, що Білл Гейтс хотів зробити як в операційній системі CP/M,
яку він брав за прототип для DOS.
Але... але поплутав напрямок слешу.
Чи правда це чи ні---сказати не можу.
Але ми поки що працюємо в Linux, поки навчаємося основам програмування, тому просто використовуємо слеш \file{/}.

Найбільш уважні читачі вже помітили, що шлях також починається з символу \chr{/}.
Це не просто так, а ознака, що перед нами повний шлях до файлу (full path).
Ще його називають абсолютним шляхом до файлу (absolute path).
У системі є особлива коренева директорія, яка позначається єдиним символом \chr{/} та яка називається рут, корінь (root).
Таким чином, шлях \file{/home/cat} означає: почати з кореневої директорії \file{/}, перейти до директорії \file{home}, а потім до директорії \file{cat}.
Це нагадує поштову адресу: країна, область, місто, вулиця, номер будинку---кожен наступний рівень уточнює місцезнаходження.

А що ж таке ця кореневa директорія?
Це початок усіх початків у файловій системі Linux.
Найчастіше це перша директорія на фізичному диску.
А якщо дисків два?
Швидше за все на тому, де розташована система.
Але це можна не тільки налаштовувати, але навіть змінювати під час роботи.
Але про це поговоримо трохи пізніше у розділі \TODO{посилання на розділ про монтування}.

Припустимо, що у нас є root директорія, яку правильно налаштував сісадмін.
Ми знаємо, що поточна директорія це \file{/home/cat}.

Ми вже знаємо, що команда \cmdd{ls} виводить вміст поточної директорії:
\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} ls
\textcolor{termdir}{labs  local  projects  sources  terminal-experiments-119}
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Ми знаємо, що в \cmdd{ls} можна передавати параметром ім'я директорії.
Ми знаємо, що поточна директорія це \file{/home/cat}.
Тоді команда \cmdd{ls /home/cat} має бути аналогічна до простого \cmdd{ls}.
Спробуємо:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} ls /home/cat
\textcolor{termdir}{labs  local  projects  sources  terminal-experiments-119}
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Вуаля! Нічого не змінилося. Наша теорія правильна.

\begin{exercise}
Подивіться вміст кореневої директорії \file{/}.
Чи є там директорія \file{home}, як у мене?
Якщо є, то подивіться на її вміст також.
\end{exercise}

Ну що, повертаємося до нашої поточної директорії.
Ми бачили там нащадок наших попередніх досліджень \file{terminal-experiments-119}.
Спробуємо вивести її вміст на екран.
Тут будьте уважними!
Для моєї сесії це буде команда \cmdd{ls /home/cat/terminal-experiments-119},
але шлях до директорії у вас швидше за все буде відрізнятися,
хіба що ви також для себе створили користувача \file{cat}!

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} ls /home/cat/terminal-experiments-119
\textcolor{termdir}{files1  files2  files3}
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Прекрасно!
Сподіваюся, ви не набирали цю команду символ за символом?
Так, швидше за все \cmdd{ls} з прогаликом треба набрати вручну.
Але далі десь в історії має бути результат команди \cmdd{pwd},
де ми бачили повний шлях до поточної директорії.
Дивимося на попередній вивід, знаходимо, вставляємо.
Потім треба набрати слеш і знову можна знайти потрібну назву вище,
або набрати \cmdd{ter} та використати автодоповлення.

\begin{exercise}
Спробуйте різні методи швидкого набору цієї довгої команди.
Який здається вам зручнішим?
\end{exercise}

Але ви мали б здогадатися, що команду можна скоротити!

\begin{exercise}
Чи можна скоротити команду\par\cmdd{ls /home/cat/terminal-experiments-119}?
\end{exercise}

Дійсно, \cmdd{ls terminal-experiments-119}!
Ця простіша версія виведе те ж саме:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} ls terminal-experiments-119
\textcolor{termdir}{files1  files2  files3}
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Придивимося пильніше до шляху.
Повне ім'я починається з \chr{/}, та подорож починається з кореневої директорії.
Але, якщо у нас ім'я не починається з \chr{/}, то подорож починається з поточної директорії.
Такий шлях називають відносним шляхом (relative path).

Коли у нас повне ім'я, яке починається з \chr{/},
то ми починаємо шукати з кореневої директорії.
Але, якщо у нас ім'я не починається з \chr{/},
то ми починаємо шукати з поточної директорії.
Такі шляхи називають відносними шляхами.

У нашій директорії~119 поки що є тільки директорії,
які інколи називають уточнюючи піддиректоріями.
Але непогано було б створити й файл.
Це можна зроюити за допомогою наступної команди:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} touch terminal-experiments-119/my-file
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} ls terminal-experiments-119
\textcolor{termdir}{files1  files2  files3}  my-file
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Ми бачимо, що з'явився новий файл \file{my-file}.
Раніше його не було, тому можна здогадатися, що \cmdd{touch} створює новий файл.
Це дійсно так, але насправді команда \cmdd{touch} більш хитра---її основне призначення
полягає в оновленні дати та часу останньої зміни файлу.
А створення нового файлу це швидше побічний ефект:
«Якщо файлу немає, то як же я можу оновити його дату? Ну добре, створю пустий!»

Тепер спробуємо виконати трохи іншу команду:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} ls -l -a -h terminal-experiments-119
total 4.0K
drwxr-xr-x  5 cat cat  6 Jun 21 16:02 \textcolor{termdir}{.}
drwxr-xr-x 17 cat cat 26 Jul  3 12:41 \textcolor{termdir}{..}
drwxr-xr-x  2 cat cat  2 Jun 21 16:02 \textcolor{termdir}{files1}
drwxr-xr-x  2 cat cat  2 Jun 21 16:02 \textcolor{termdir}{files2}
drwxr-xr-x  2 cat cat  2 Jun 21 16:02 \textcolor{termdir}{files3}
-rw-r--r--  1 cat cat  0 Jul  3 16:35 my-file
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Що змінилося?
По-перше, ми додали три опції: \term{-l}, \term{-a} та \term{-h}.
По-друге, замість скупого переліка ми отримали справжній звіт!
Замість простого списку імен ми бачимо таблицю з детальними відомостями про кожен файл.
Ніби-то у переглядачі файлів змінили іконки на таблицю!
Спочатку розберемося з тим, що ми змінили.

Опція \term{-l} означає довгий формат (long format).
Це означає, що до кожного файлу буде додана детальна інформація про нього.
Опція \term{-a} означає, що ми хочемо бачити усі файли (all).
Прихованими в Linux є файли, імена яких починаються з крапочки.
Так у нас з'явилися \file{.} та \file{..}---дві магічні директорії, про які трохи пізніше.
Опція \term{-h} визначає, як ми хочемо бачити розміри.
Без цієї опції ми будемо бачити точну цифру на кшталт \term{747396},
з нею людяний (human) формат \term{729K}, що означатиме 729~кілобайт.

Тепер розберемо цей криптографічний вивід по частинах.

Перший рядок \term{total 4.0K} показує загальний розмір дискового простору,
який займають усі файли та директорії у цій папці.
Тут це чотири кілобайти.
Звучить просто, але насправді не зовсім!
Проблема у тому, що в підрахунках беруть участь лише файлі, що лежать в цій директорії.
Щодо піддиректорій, то враховується лише місце,
яке потрібне для зберігання списку їхнього вмісту,
а не розмір файлів всередині них.
Тобто, ящо директорія \file{files2} містить гігабайтний файл,
то все одно там буде врахована лише довжина імені,
навряд чи в результаті буде більше за \term{4.0K}.

Чому так?
Уявіть собі, що ви хочете просто детально подивитися на файли в кореневій директорії,
а система починає рахувати усі файли в системі.
З плюсів, що ви встигнете випити каву і подумати про сенс буття,
але... чи того ви хотіли?

Якщо не вказувати \term{-h}, то побачимо просто \term{total 4}.
Чотири чого?  Чотири блоки. Яких блоки? Блоки по 1024 байти.
Якщо ви знаєте про блоки файлової системи, то це не вони.
Для команди \cmdd{ls} один блок це один кілобайт, так склалося історично,
до цього звикли, написали купу софта, що очікує саме це,
тому й міняти потім, коли з'явилися різні розміри блоків, не стали.

Тепер уважно подивимося на типовий рядок:
\par\term{drwxr-xr-x~~2 cat cat~~2 Jun 21 16:02 files1}

Це справжня скарбничка інформації!
По-перше, загадкові літери \term{drwxr-xr-x} це права доступу до файлу.
Тема настільки захоплююча, що заслуговує на окремий розділ.
Поки що просто запам'ятайте, що \term{d} на початку означає директорію,
а \term{-} (як у нашого файлу \file{my-file}) означає звичайний файл.

Далі цифра \term{2} це кількість жорстких посилань на цей файл.
Якщо вам здається, що це якась езотерика, то ви не помиляєтеся.
Більшість користувачів Linux живуть щасливо, навіть не знаючи, що таке жорстке посилання.
Ми про це поговоримо, але... не зараз.

Далі у нас два рази йде \term{cat}.
Ви пам'ятаєте, що \term{cat} це ім'я користувача, під яким я працюю?
Так, тут перший як раз ім'я власника файлу.
Другий---ім'я групи, до якої належить файл.
Не дивуйтеся, що вони однакові, часто в Linux створюють групу з таким же ім'ям, як користувач.
Що не заборонено, то дозволено.

Наступна цифра показує розмір.
Для директорій це кількість елементів всередині, а для звичайних файлів це розмір.
Для нашого єдиного \file{my-file} це \term{0}, бо \cmdd{touch} створила порожній файл.
Для більшого файлу ми побачили б щось на кшталт \term{729K} (729 кілобайт, завдяки опції \term{-h}).

Нарешті, \term{Jun 21 16:02}---дата та час останньої зміни файлу.
Зверніть увагу на \term{Jul 3 16:35} для \term{my-file}, це час, коли я пишу цей розділ, третє липня.
А рік? Який рік?
Рік поточний, система не показує його, щоб заощадити місце.

Ну й \file{files1} це власне ім'я файлу.

\begin{exercise}
Спробуйте знайти у вашій системі файл, створений минулого року,
тоді у виводі \cmdd{ls -l} з'явиться рік замість часу.
Або дізнайтеся у пошуку чи LLM, як змінити дату файлу за допомогою команди \cmdd{touch}.
\end{exercise}

\begin{exercise}
Спробуйте виконати команду \cmdd{ls} з усіма можливими комбінаціями трьох флагів \term{-l}, \term{-a}, \term{-h}.
Скільки різних варіантів у вас вийшло? Чим вони відрізняються? Який здається найкориснішим?
\end{exercise}

Добре, повернемося до виводу та пригадаємо наші магічні директорії:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
drwxr-xr-x  5 cat cat  6 Jun 21 16:02 \textcolor{termdir}{.}
drwxr-xr-x 17 cat cat 26 Jul  3 12:41 \textcolor{termdir}{..}
\end{Verbatim}

Що це таке?
Це дві спеціальні піддиректорії, які існують у кожній директорії файлової системи.
Щоб розібратися, допоможе команда \cmdd{realpath}, яка друкує повний шлях:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} realpath terminal-experiments-119
/home/cat/terminal-experiments-119
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Так, ми знаємо, що \file{terminal-experiments-119} містить директорію \file{.}, тому...

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} realpath terminal-experiments-119/.
/home/cat/terminal-experiments-119
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} realpath terminal-experiments-119/./././././
/home/cat/terminal-experiments-119
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Ми бачимо, що нічого не змінюється!
Одна крапка \file{.} означає «поточна директорія», тобто «тут, де ми зараз».
Можна дописати скільки завгодно \file{/./././}, результат той самий.
Це зрозуміло, але для чого це було зроблено?
По-перше, якщо ввести \cmdd{ls -l}, то ми побачимо інформацію про саму директорію: дату створення, права доступу.
По-друге, можна явно вказувати \cmdd{ls .}.
Так, у разі \cmdd{ls} можна й нічого не вказувати, але не всі команди такі.

А що з двома крапками \file{..}? Спробуємо:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} realpath terminal-experiments-119/..
/home/cat
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} realpath terminal-experiments-119/../..
/home
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} realpath terminal-experiments-119/../../..
/
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} realpath terminal-experiments-119/../../../..
/
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Ага! Кожного разу, як ми додаємо \file{/..}, зникає один рівень у шляху.
Спочатку \file{terminal-experiments-119} зник, потім \file{cat}, потім \file{home}.
Але коли ми дійшли до кореневої директорії \file{/}, то далі підніматися нікуди---
батьком кореневої директорії є вона сама!
Це як спробувати піднятися вище даху будинку, вище не можна, залишаємося там.

\begin{exercise}
Спробуйте здогадатися, який шлях виведе \cmdd{realpath} для наступних виразів,
якщо поточна директорія \file{/home/cat}:

\begin{tabular}{@{\hspace{1em}}p{0.33em}l@{}}
a) & \texttt{realpath .} \\
б) & \texttt{realpath ..} \\
в) & \texttt{realpath ../..} \\
г) & \texttt{realpath ./projects} \\
д) & \texttt{realpath ../cat} \\
е) & \texttt{realpath ../../home/cat} \\
є) & \texttt{realpath ./../././../cat/./projects} \\
ж) & \texttt{realpath /home/cat/projects/../..} \\
з) & \texttt{realpath terminal-experiments-119/../files1/../../projects} \\
и) & \texttt{realpath /../../../../..} \\
\end{tabular}

Після того, як здогадаєтеся, перевірте свої відповіді на практиці!
\end{exercise}

\medskip

Доки що в цій секції ми виконували чудову еквілібристику, не змінюючи поточну директорію.
Але вона тому й поточна, що користувач має право її обирати, як йому зручно.
Це як з адресою: якщо ви в Миргороді, то можна просто сказати «Гоголя, 139»,
а не «Україна, Полтавська область, місто Миргород, вулиця Гоголя, будинок 139».
Навіщо повторювати те, що й так очевидно?

З попереднього розділу ви знаєте про команду \cmdd{cd}.
От вона якраз і використовується для зміни поточної директорії.
Час її застосувати!

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} pwd
/home/cat
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} cd terminal-experiments-119
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~/terminal-experiments-119 $} pwd
/home/cat/terminal-experiments-119
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~/terminal-experiments-119 $} ls
   \textcolor{termdir}{files1  files2  files3}  my-file
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~/terminal-experiments-119 $}
\end{Verbatim}

Спочатку ми командою \cmdd{pwd} нагадуємо собі, де ми є.
Потім командою \cmdd{cd} переходимо в одну піддиректорію вниз.
Після її виконання ми вже у \file{/home/cat/terminal-experiments-119}.
Це можна бачити у запрошенні та підтвердить команда \cmdd{pwd}.
І остаточно переконає команда \cmdd{ls}: ми бачимо три директорії та один файл, які створювали раніше.

А що робить команда \cmdd{cd} без параметрів?
Команда \cmdd{ls} без параметрів друкує поточну директорію.
Але для \cmdd{cd} немає сенсу «перейти в поточну директорію», ми вже тут.
Логічно, що команда без параметрів має виконувати якусь корисну роботу, бо її простіше набирати.
Тому команда \cmdd{cd} без аргументів повертає нас додому, у домашню директорію.
Спробуємо та подивимося:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~/terminal-experiments-119 $} cd
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Є! У запрошенні знову бачимо тільку тільду \file{\textasciitilde}.

\begin{exercise}
Припустимо, що домажня директорія це \file{/home/cat}.
Спробуйте передбачити, що надрукують наступні послідовності команд:

\begin{tabular}{@{}l@{\hspace{1em}}p{10cm}@{}}

а) & \begin{minipage}[t]{10cm}
\begin{Verbatim}[fontsize=\footnotesize]
cd
cd terminal-experiments-119
realpath .
\end{Verbatim}
\end{minipage} \\[1em]

б) & \begin{minipage}[t]{10cm}
\begin{Verbatim}[fontsize=\footnotesize]
cd /home/cat/terminal-experiments-119/files1
realpath .
\end{Verbatim}
\end{minipage} \\[1em]

в) & \begin{minipage}[t]{10cm}
\begin{Verbatim}[fontsize=\footnotesize]
cd
cd terminal-experiments-119/files1
realpath ../..
\end{Verbatim}
\end{minipage} \\[1em]

г) & \begin{minipage}[t]{10cm}
\begin{Verbatim}[fontsize=\footnotesize]
cd /.././home/cat/terminal-experiments-119/../
realpath ..
\end{Verbatim}
\end{minipage} \\[1em]

\end{tabular}

Перевірте свої здогадки, виконавши ці команди.
\end{exercise}

\medskip

Якщо ви пам'ятаєте Norton Commander, то його головною перевагою були дві панелі.
Це дозволяло не тільки зручно копіювати й переміщувати файли між директоріями,
але й швидко перемикатися між двома робочими місцями.
Таке життя, що нам дуже часто треба перериватися,
щоб перевірити щось в іншій директорії,
а потім або повернутися, або перевірити ще третє місце,
а потім або повернутися, або...
Яка найбільша кількість графічних переглядачів файлів була у вас відкрита?

А як бути у командному рядку?
Найпростіше рішення: треба запустити багато терміналів.
Так зазвичай і роблять,
у профі часто можна бачити багато відкритих одночасних вкладок.
Але є ще інший шлях.
Не можу сказати, що він дуже зручний та ним багато хто користується.
Але це гарна можливість трохи підвищити навички роботи в командному рядку.

Досі ми використовували команду \cmdd{cd} для переходу між директоріями.
Це працює, але \cmdd{cd} це дорога в один кінець.
Пішов туди, забув звідки прийшов.
Хочеш повернутися? Згадуй шлях або тицяй \keys{\ctrl+R} у пошуках історії.
Але існує альтернатива: команда \cmdd{pushd}.
Вона робить те саме, що й \cmdd{cd}, переводить вас у нову директорію.
Але з одним бонусом: запам'ятовує, звідки ви прийшли!
А потім командою \cmdd{popd} можна миттєво повернутися назад.
Це як телепорт із закладкою на попереднє місце.

Давайте спробуємо наші нові знання:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} pwd
/home/cat
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} pushd terminal-experiments-119
~/terminal-experiments-119 ~
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~/terminal-experiments-119 $} pwd
/home/cat/terminal-experiments-119
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~/terminal-experiments-119 $} popd
~
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} pwd
/home/cat
\end{Verbatim}

Що тут відбувається?
Час від часу ми викликаємо команду \cmdd{pwd},
щоб переконатися у тому, яка поточна директорія зараз.
Так, це додаткова необов'язкова дія, бо ми й так це бачимо у промпті.
Але повторити не завадить.

Команда \cmdd{pushd terminal-experiments-119} перенесе нас до нової директорії.
На відміну від \cmdd{cd}, команда \cmdd{pushd} не мовчить!
Вона друкує поточний список директорій: нашу 119 та хом'як \term{\textasciitilde}.
Це означає, що зараз ми у новій директорії,
але система запам'ятала нашу попередню локацію \file{\textasciitilde},
куди ми повернемося, коли наберемо \cmdd{popd}.
Що ми далі й робимо, і \cmdd{popd} знову додатково друкує поточний стан.

Зазвичай у літературі при описі цих команд можна знайти термін «стек директорій».
Я не хотів вас лякати словом «стек», але пару слів сказати можна.
Список директорій, який друкується, насправді не простий список, а скоріше стопка книг.
Уявіть собі стопку на столі: щоб покласти нову книгу, ви кладете її зверху---це наша \cmdd{pushd}.
Але взяти (\cmdd{popd}) ми можемо лише верхню книгу зі стопки.
Якщо у такій конструкції є доступ лише до останнього елементу, то це називається стек (stack).
Ще інколи використовують термін LIFO (Last In, First Out), «останній зайшов, перший вийшов»,
який показує, як працюють операції покласти та забрати.

Як у реальному житті можна схитрити та забрати книжку з-під низу,
так і тут є спеціальні опції у команди \cmdd{popd}, які ми дослідимо пізніше у вправах.

Але що робити, якщо набрати \cmdd{pushd} без параметрів?
Так, ніби-то розумної дії в голову не приходить.
Але набирати без параметрів так зручно, тому треба щось корисне, ніж повідомити про помилку.
Є варіанти?
\cmdd{pushd} без параметрів просто міняє місцями останні дві директорії у стеку.
Це корисно, якщо у вас лише дві робочі локації,
тоді можна один раз зробити \cmdd{pushd куди-треба},
а потім переключатися між ними простим \cmdd{pushd} без параметрів.

Час переходити до прокачування скілу!

\begin{exercise}
Відвідайте директорії \file{/bin}, \file{/usr/bin}, \file{/etc} через \cmdd{pushd},
подивіться їх вміст та поверніться назад.
\end{exercise}

\begin{exercise}
Зробіть стек з чотирьох директорій
та дослідіть, що роблять команди \cmdd{popd -n}, \cmdd{popd -2}, \cmdd{popd +2}.
\end{exercise}

\begin{exercise}
Аналогічно до попередньої вправи поекспериментуйте з командами \cmdd{pushd -n}, \cmdd{pushd +2}, \cmdd{pushd -2}.
\end{exercise}

\begin{exercise}
Спробуйте виконати \cmdd{pushd} без параметрів, коли стек порожній. Що буде?
\end{exercise}

\begin{exercise}
Методом проб та помилок спробуйте здогадатися, що робить команда \cmdd{cd -}.
\end{exercise}

\begin{summary}
\item Є поточний шлях, а є абсолютний.
\item Є поточна директорія, є домашня, а є коренева.
\item Команда \cmdd{ls} показує вміст директорії, \cmdd{cd} змінює поточну директорію.
\item Є екзотичний стек директорій та команди \cmdd{pushd} та \cmdd{popd}.
\end{summary}

\section{Команди, команди, команди...}

У попередніх розділах ми познайомилися з купою команд: \cmdd{ls}, \cmdd{cd}, \cmdd{mkdir}, \cmdd{pushd}.
Бачили різні опції, наприклад \term{-l}, \term{-a}, \term{-h}.
Передавали аргументи---імена файлів та директорій.
Але все це було трохи хаотично, як вивчення іноземної мови через розмовник для туристів.
«Де тут туалет?», «Скільки коштує пиво?».
Це корисно, але й граматику знати корисно теж.
Тепер настав час систематизувати наші знання та зрозуміти загальну структуру команд,
швидше освоювати нові команди та не плутатися у документації.

Кожна програма, коли запускається, отримує від системи список аргументів.
У принципі, програма може обробляти їх як заманеться це її внутрішня справа.
Але існують правила гарного тону, які описані у стандарті POSIX.
Більшість сучасних програм слідує цим правилам.
Деякі архаїчні команди можуть їх порушувати,
або мають свої особливості з історичних причин.
Ми їх розберемо пізніше, а поки сконцентруємося на тому,
як саме передавати аргументи командам.
І допоможе нам в цьому команда \cmdd{echo},
яка просто друкує свої аргументи через прогалик.

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} echo 1     2            3
1 2 3
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Бачимо, що незважаючи на різну кількість прогаликів між цифрами,
команда \cmdd{echo} надрукувала їх через один прогалик.
Це тому, що наша команда спочатку була розбита на чотири окремі аргументи:
\term{echo}, \term{1}, \term{2}, \term{3}.
А \cmdd{echo} просто вивела їх через один прогалик, як і завжди.
Додаткові прогалики «з'їлися» ще до запуски \cmdd{echo}.

Так, ми побачили, що прогалик це спеціальний символ, який розділяє аргументи.
Але не він один такий!
Наприклад:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} echo echo -- echo echo
echo -- echo echo
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} echo echo && echo echo
echo
echo
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Якщо перша команда відпрацювала очікувано й просто надрукувала усі свої аргументи,
то друга команда несподівано надрукувала слово \term{echo} двічі з нового рядка.
Можна здогадатися, \chr\& також спеціальний символ,
а подвійний амперсанд \term{\&\&} розділяє команди.
Тонкощі поки що опустимо.
Нижче можна побачити всі спеціальні символи\footnote{
Також спеціальними є табуляція, перенос рядка та деякі інші недруковані символи.
}:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
␣ ! " # $ & ' ( ) * , ; < > ? [ \ ] ^ ` { | }
\end{Verbatim}

Так, цих символів багатенько...
І що робити, якщо хочеться вивести їх у команді \cmdd{echo}?
Вихід є, і не один.
Можна використовувати зворотний слеш \chr{\textbackslash} перед символом:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} echo \textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>\textbackslash<\textbackslash>
<><><><><><><><><><><><><>
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Зворотний слеш \chr{\textbackslash} каже командному рядку:
«наступний символ не обробляй як спеціальний, а передай як звичайний текст».
Це називається екрануванням символу.

\begin{exercise}
Спробуйте виконати команду без екранування:
\par\term{echo <><><><><><><><><><><><><><><>}
\par Що відбудеться?
\end{exercise}

Так, ми досягли нашої мети й надрукували орнамент.
Але... чи це зручно?
Ні, тому є інший спосіб---апострофи:

\begin{Verbatim}[fontsize=\footnotesize,commandchars=\\\{\},xleftmargin=\parindent]
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $} echo '<><><><><><><><><><><><><>'
<><><><><><><><><><><><><>
\textcolor{termuser}{cat@mustitz} \textcolor{termdir}{~ $}
\end{Verbatim}

Усе, що знаходиться між апострофами,
передається як єдиний аргумент без жодної обробки.
Це набагато зручніше, ніж екранувати кожен символ окремо.

\begin{exercise}
Спробуйте що буде, якщо не відкрити апостроф, але не закрити.
\end{exercise}

\begin{exercise}
Спробуйте здогадатися, що виведуть наступні команди:

\begin{tabular}{@{\hspace{1em}}p{0.33em}l@{}}
a) & \texttt{echo 1 2~~3~~~4} \\
б) & \texttt{echo '1 2~~3~~~4'} \\
в) & \texttt{echo '\textbackslash\textbackslash\textbackslash\textbackslash'} \\
г) & \texttt{echo '\$\$\$\$'} \\
д) & \texttt{echo \textbackslash\textbackslash\textbackslash\textbackslash} \\
е) & \verb|echo ''''| \\
\end{tabular}

Виконайте їх та перевірте свої здогадки.
\end{exercise}

\begin{exercise}
Які з наступних команд \cmdd{echo} успішно надрукують щось,
а які призведуть до помилки?

\begin{tabular}{@{\hspace{1em}}p{0.33em}l@{}}
a) & \texttt{echo hello-world hello+world} \\
б) & \verb|echo 'I can't wear Ann's dress'| \\
в) & \verb|echo \'test'('| \\
г) & \verb|echo '\'\(| \\
д) & \verb|echo \'(\)'| \\
е) & \verb|echo '\'\\''\\\\'\\\'| \\
є) & \verb|echo '('\)'(\'\)(')'| \\
\end{tabular}

Спробуйте здогадатися, а потім перевірте на практиці.
Якщо ви припустилися помилки, то спробуйте знайти де саме шляхом виводу по частинам.
\end{exercise}

\medskip

Усі аргументи команди можна розділити на дві основні категорії:
опції або прапорці (flags) та позиційні аргументи.
Прапорці зазвичай починаються з дефіса \chr{-} і змінюють поведінку команди.
Поки що ми познайомилися з трьома прапорцями:
\term{-l} (детальний формат виводу),
\term{-a} (показати усі файли, включно з прихованими)
та \term{-h} (людяний друк розмірів).
У якості позиційних аргументів у нас були імена файлів та директорій.
І була особлива команда \cmdd{echo}, якій було байдуже прапорець чи позиційний аргумент,
вона просто друкувала усе що бачила.

Про позиційні аргументи особливо сказати нічого, це простий текст.
Як я вже згадував, це може бути шлях до файлу або директорії,
але також це можуть бути числа, команди, слова або будь-який інший текст,
який команда має обробити.
